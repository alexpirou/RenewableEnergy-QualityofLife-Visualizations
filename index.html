<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scatter Plot</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
  body {
    font-family: Arial, Helvetica, sans-serif;
    background-color: rgb(255, 255, 255);
    color: rgb(0, 0, 0);
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  p {
    width: 75%;
  }

  #radarChart #map{
    background-color: #333;
  }

  h1 {
    margin-top: 20px;
  }

  .slider-container {
    margin-top: 10px;
    display: flex;
    align-items: center;
  }

  .slider {
    margin-left: 10px;
  }

  .tooltip {
    position: absolute;
    text-align: center;
    background: white;
    border: 1px solid #ddd;
    padding: 5px;
    border-radius: 4px;
    pointer-events: none;
    font-size: 14px;
    display: none; 
  }

  #graph-description {
    margin-left: 200px;
  }

  .line {
    fill: none;
    stroke-width: 4px;
  }

  .gridlines line {
    stroke: #bbb;
  }

  .gridlines .domain {
    stroke: none;
  }

  .axis-label {
    font-size: 14px;
    font-weight: bold;
  }

  .y-axis-energy .tick text {
    fill: #53C44F;
    font-size: 14px;
  }

  .y-axis-life .tick text {
    fill: #5F9DD4;
    font-size: 14px;
  }

  .y-axis-co2 .tick text {
    fill: #EC5042;
    font-size: 14px;
  }

  .legend {
    font-family: Arial, sans-serif;
    font-size: 12px;
  }

  .legend-box {
    stroke: #000;
    stroke-width: 1px;
    fill: rgba(255, 255, 255, 0.8);
  }

  #button-bar {
    margin-top: 10px;
  }

  button {
    margin-right: 5px;
    padding: 5px 10px;
    font-size: 14px;
  }

  p {
    color: #000;
  }
  </style>
</head>
<body>
  <h1>Renewable Energy and Quality of Life Correlation</h1>
  <p>Contributors: Alexander Pirouznia, Carl Chen, Simon Tian, Jason Lee</p>

  <p>This project combines multiple datasets to create a comprehensive visualization of global socioeconomic and environmental trends. The data sources include the Regional Cost of Living Analysis, the World Bank’s Life Expectancy and Socioeconomic Dataset, and Global Renewable Energy Production Data. These datasets provide critical insights into six key indicators: renewable energy production, life expectancy, healthcare spending, CO₂ emissions, cost of living, and average income. The data spans multiple years, enabling temporal and spatial analyses of trends and correlations across countries.</p>

  <h2>Dataset Analysis</h2>
  <p><a href="https://www.kaggle.com/datasets/heidarmirhajisadati/regional-cost-of-living-analysis">Regional Cost of Living Analysis:</a> This dataset includes data on cost of living, which provides insights into the affordability of goods and services in different countries. It also includes information about average monthly incomes, enabling a comparison of economic well being.<p>
  <p><a href="https://www.kaggle.com/datasets/mjshri23/life-expectancy-and-socio-economic-world-bank">Expectancy and Socioeconomic Data from the World Bank:</a> This dataset highlights key socioeconomic indicators, including average life expectancy, healthcare expenditure, and CO₂ emissions. These metrics are crucial for understanding the quality of life and environmental impact across regions.<p>
  <p><a href="https://www.kaggle.com/datasets/ahmedgaitani/global-renewable-energy">Global Renewable Energy Production Data:</a> This dataset offers a breakdown of renewable energy production by type (e.g., solar, wind, hydro) and total output per country. It serves as a critical metric for evaluating the adoption of sustainable energy practices and their socioeconomic implications.<p>
  <p>To ensure data quality, extensive preprocessing was conducted. Missing values were addressed, invalid entries were removed, and metrics were normalized where appropriate. The datasets were merged into a cohesive format for analysis, enabling consistent comparisons across countries and years.</p>

  <h2>Interactive Global Radar Chart</h2>
  <div id="map-container">
  <svg id="map" width="800" height="500"></svg>
  <svg id="radarChart" width="500" height="500"></svg>
  </div>
  <div class="slider-container">
    <label for="yearSlider">Year:</label>
    <input type="range" id="yearSlider" class="slider" min="2000" max="2023" step="1" value="2000">
    <span id="yearDisplay">2000</span>
  </div>
  <div class="tooltip" id="tooltip"></div>
  <p>The world map serves as the central visualization for exploring geographically distributed data. Designed using D3.js and GeoJSON, the map provides an intuitive and spatially contextualized view of global data, allowing users to identify patterns across countries effectively. Countries with available data are highlighted in teal, while those without data are displayed in a muted gray, ensuring a clear visual distinction. The map adopts a clean dark theme with a dark gray background and white country boundaries to enhance visibility and reduce visual clutter, drawing attention to the highlighted countries.
  Interactivity plays a key role in the map's design. When users hover over a country, a tooltip displays the country name, providing immediate feedback. This interactive element ensures users can easily identify and explore regions of interest. The hover interaction dynamically connects the map to other visualizations, allowing for seamless updates and reinforcing the spatial relevance of the data. The choice of a world map aligns with the goal of presenting global data in an engaging and accessible way, enabling users to compare information across countries while maintaining a strong focus on usability and visual clarity. By combining interactivity with a clean, dark-themed design, the map delivers a powerful and engaging platform for global data exploration.
  </p>
  <p>The radar chart was chosen as a complementary visualization to the world map, providing an intuitive and compact way to display multidimensional data for each country. By focusing on six key indicators—Renewable Energy, Life Expectancy, Healthcare Spending, CO₂ Emissions, Cost of Living, and GDP per Capita—the radar chart allows users to compare multiple metrics simultaneously. This makes it particularly effective for visualizing categorical or grouped data where traditional charts, such as bar or line charts, might struggle to convey relationships and trends clearly. The radar chart helps users quickly identify strengths, weaknesses, and patterns within a country’s data across all six dimensions.
  Interactivity enhances the radar chart’s utility, as it dynamically updates based on the hover interaction on the world map. When a user selects or hovers over a country, the radar chart seamlessly reflects that country’s data, ensuring a cohesive and responsive user experience. This connection between the world map and radar chart enables users to contextualize the selected country’s performance in a visually appealing manner. The chart employs a clean dark theme that matches the overall design, with light blue fill and blue stroke for the data area. Gridlines and axes are styled in subtle gray to provide structure without overwhelming the visualization. Smooth transitions are applied when updating the radar chart, ensuring a polished and fluid user experience.
  Overall, the radar chart was implemented to offer a clear, engaging, and efficient way to compare multidimensional data. Its design and interactivity ensure that users can quickly understand a country’s performance across multiple indicators while maintaining a strong visual connection to the world map.
  </p>
  <h2>CO2 Production, Wealth, and Renewable Energy Use Comparison</h2>
  <div id="bubble-chart"></div>
  <p>This visualization reveals insights into the relationships between wealth, human development, and environmental impact. Life expectancy emerges as a leading indicator of economic prosperity, with a clear gradient across income levels. High-income regions consistently demonstrate life expectancies exceeding 70 years, in contrast to lower-income areas where life expectancy falls below 60 years.</p>

  <p>Rather than following a linear progression tied to income, renewable energy usage clusters most densely in the mid-range, spanning approximately 2,000 to 3,500 GWh. This suggests a more nuanced relationship between economic development and sustainable energy adoption, challenging assumptions about wealth and green energy implementation.</p>

  <p>The carbon emissions profile presents another layer of complexity. CO2 levels exhausted from fossil fuel consumption display the most variation at higher income levels, with an amplified footprint compared to lower-income regions. While lower-income areas contribute a minimal carbon emissions signature, the data highlights the disproportionate environmental impact of economies with large wealth gaps.</p>

  <div id="graph-description">
      <h2>Time Series Line Graph</h2>
  </div>
  <div id="chart"></div>
  <div class="tooltip" id="tooltip"></div>
  <p>The visualization is a time-series line chart comparing CO2 emissions, average life expectancy, and global annual renewable energy production from 2000 to 2020.The x-axis represents time, allowing viewers to track changes over the 20-year period, while the y-axes represent the three variables. The left y-axis is shared between life expectancy and CO2 emissions to conserve space and simplify interpretation, with color coding ensuring clear differentiation. Renewable energy production is placed on a separate right y-axis due to its much larger scale, in order to prevent distortion and maintain accuracy.  </p>

  <p>Color is a key visual tool, with each variable assigned a distinct and meaningful shade: red for CO2 emissions, emphasizing urgency; blue for life expectancy, symbolizing health; and green for renewable energy, representing environmental progress. Trends are primarily represented by lines, which allow for smooth tracking over time, while circles mark individual data points to enhance precision and make specific values easily identifiable. Linear scales are used for all axes to preserve proportional relationships and ensure trends are intuitive to interpret.</p>

  <p>The interactive elements of the visualization focus on providing clarity and enhancing user engagement through the use of tooltips and interactive data points. Tooltips are a central feature, appearing when users hover over individual data points along the lines. These tooltips display detailed information, such as the exact values for CO2 emissions, life expectancy, or renewable energy production for a given year. This design decision allows viewers to explore the chart with greater precision, offering immediate, contextual feedback without cluttering the overall visualization. Tooltips are positioned intuitively and styled to remain unobtrusive, ensuring they provide value without overwhelming the user.</p>

  <p>The inclusion of data point markers—represented as circles along the lines—also enhances discoverability and usability. These markers signal to users that the chart is interactive and provide clear targets for hovering. This interaction choice is simple, familiar, and effective for enabling deeper exploration while keeping the visualization clean and focused. By limiting interactions to hover-based tooltips, the design avoids unnecessary complexity and ensures that the chart remains approachable for users of all skill levels.</p>

  <p>Examining the trends of CO2 emissions, global renewable energy production, and life expectancy from 2000 to 2020 reveals a combination of progress and inconsistency. Life expectancy has steadily increased over the two decades, reflecting advancements in healthcare, living conditions, and overall development. However, this positive trajectory contrasts with the persistently high CO2 emissions, which have shown little meaningful decline. This suggests that while human well-being has improved, it continues to be supported by fossil fuel reliance, highlighting the environmental costs of global growth.</p>

  <p>The trend in renewable energy production was particularly unexpected. Given the urgency of the climate crisis and the global emphasis on sustainability, I anticipated consistent growth over the years. Instead, the data reveals large fluctuations, with significant increases, such as from 2002 to 2003, followed by notable declines, especially between 2009 and 2011. By 2020, production had even fallen below 2000 levels, suggesting an overall lack of sustained progress. These inconsistencies may be due to the weather-dependent nature of renewable energy or variability in infrastructure investment and policy support. Together, these trends show that while life expectancy has seen steady improvement, renewable energy production has not followed a clear upward trajectory, and CO2 emissions remain unchanged, reflecting a complex relationship between development and environmental impact.</p>

  <h2>Renewable Energy Sources by Country</h2>
  <div id="container">
      <svg id="barchart" height="600" width="900" style="background: #ffffff;"></svg>
  </div>
  <div id="button-bar"></div>
  <div id="tooltip" class="tooltip"></div>
  <p>Using the interactive year buttons, we can see that there really is no specific trend between countries or the renewable energy sector with heavy fluctuations from the years 2000 to 2023. There is no dominant country in renewable energy production, the different sectors themselves (wind, solar, hydro, other) waver on a year to year basis. However, we can see that overall renewable energy production is tending to grow on a year by year basis. We believe these fluctuations are testament to the unpredictability of weather that may impede solar, hydro, or wind development. For example, solar production is contingent on there being ample sunlight, and wind production is contingent on there being high wind speeds. Both are unpredictable and uncontrollable.</p>

  <p>If we narrow down our analysis to the last five years, we can analyze a smaller subset that is more directly applicable to modern days. We see within the last five years, that wind and hydro energy usually take up the bulk of renewable energy production. In addition, solar production has been generally increasing, besides for a lull in 2021. Wind energy too, has seen steady growth. Hydro, is perhaps the most stable, because it depends the least on the weather due to manmade dams and aqueducts. However, even this too may be reliant on weather forces affecting rain or drought.  Finally, other renewable energies round it out, usually providing a small subset within production due to their gradual diversification within the energy sector mix. 
  Within a country by country basis, we notice several trends. For one, there is no dominating country in total renewable energy production, although France seems to consistently output high levels of production. All countries seem to perform better than others in specific sectors, and even then that changes on a year to year basis. There are no dominant performances, where a country has led production in all four categories.  Furthermore, China consistently outputs high levels of hydro power production, while Australia consistently outputs high levels of wind power production. </p>

  <p>Because of this, if there was one notable thing that could be improved from the visualization it would be the addition of a total energy production bar (with all the countries combined). This could be helpful for the larger picture of each year, to show growth in renewable energy in the grander scope and not only on a country by country basis. This could help a user visualize the larger picture more immediately throughout the years, whereas separating by country may provide a too muddled approach that is hard to grasp the overall changes. </p>

  <h2>Observations and Conclusion</h2>
  <p>Renewable Energy and Socioeconomic Indicators: Countries with higher adoption of renewable energy sources often exhibit better socioeconomic indicators, such as higher life expectancy and average income, coupled with lower CO₂ emissions.</p>
  <p>Low-income regions often face challenges in renewable energy adoption, with corresponding lower socioeconomic outcomes.</p>
  <p>Temporal Progress: Over the years, many countries have made significant strides in renewable energy adoption, which often correlates with improvements in life expectancy and reductions in CO₂ emissions.</p>
  <p>Sustainability Challenges: Some regions with high renewable energy production still face challenges in socioeconomic indicators, highlighting the complexity of achieving sustainability.</p>
  <p>By integrating these insights into an interactive platform, the project provides a powerful tool for exploring global trends and their implications. Policymakers, researchers, and the public can use these visualizations to better understand the interconnectedness of socioeconomic factors and environmental sustainability, and to identify opportunities for improvement globally.</p>
  <script>
    //Radar Graph
    const drawRadarChart = (function () {
      const parameters = ["Renewable", "LifeExpectancy", "Healthcare", "CO2", "CostOfLiving", "AverageIncome"];
      const angleSlice = (Math.PI * 2) / parameters.length;
      const radarWidth = 500, radarHeight = 500, radius = Math.min(radarWidth, radarHeight) / 2 - 50;
      const centerX = radarWidth / 2, centerY = radarHeight / 2;

      const mapSvg = d3.select("#map");
      const radarSvg = d3.select("#radarChart");
      const tooltip = d3.select("#tooltip");
      const yearSlider = d3.select("#yearSlider");
      const yearDisplay = d3.select("#yearDisplay");

      let scales = {};
      let globalData = {};
      let currentYear = "2000";
      let selectedCountry = null; 
      let countries = new Set(); 

      const radarLine = d3.lineRadial()
          .angle((d, i) => i * angleSlice)
          .radius(d => scales[d.parameter](d.value))
          .curve(d3.curveLinearClosed);

      // Load data and GeoJSON
      Promise.all([
          d3.json("global.geo.json"),
          d3.csv("Combined_cleaned_reduced.csv"),
      ]).then(([geoData, combinedData, costOfLiving]) => {
          processData(combinedData, costOfLiving);
          drawMap(geoData);
          updateRadar({}); 
      });

      function processData(combinedData, costOfLiving) {
          combinedData.forEach(d => {
              const country = d.Country;
              const year = d.Year;
              if (!globalData[country]) globalData[country] = {};
              globalData[country][year] = {
                  Renewable: +d.TotalRenewableEnergy || 0,
                  LifeExpectancy: +d.Life_Expect || 0,
                  Healthcare: +d.Health_Expenditure || 0,
                  CO2: +d.CO2 || 0,
                  CostOfLiving: +d.Cost_of_Living || 0,
                  AverageIncome: +d.Average_Monthly_Income || 0
              };
              countries.add(country);
          });
      }

      function drawMap(geoData) {
        const projection = d3.geoMercator().fitSize([800, 500], geoData);
        const path = d3.geoPath().projection(projection);
    
        mapSvg.selectAll("path")
            .data(geoData.features)
            .join("path")
            .attr("d", path)
            .attr("fill", d => countries.has(d.properties.name) ? "#c7f5ff" : "#444")
            .attr("stroke", "black")
            .attr("class", "country")
            .on("mouseover", (event, d) => {
                const country = d.properties.name;
                tooltip.style("visibility", "visible").text(country);
            })
            .on("mousemove", event => {
                tooltip.style("top", (event.pageY - 20) + "px")
                      .style("left", (event.pageX + 10) + "px");
            })
            .on("mouseout", () => {
                tooltip.style("visibility", "hidden");
            })
            .on("click", (event, d) => {
                selectedCountry = d.properties.name;
                updateRadarCountry(selectedCountry);
    
                mapSvg.selectAll(".country")
                    .attr("fill", d => {
                        if (d.properties.name === selectedCountry) {
                            return "#ffa500"; // orange highlighting
                        }
                        return countries.has(d.properties.name) ? "#c7f5ff" : "#444";
                    });
            });
    }

      function updateRadarCountry(country) {
          if (!country || !globalData[country] || !globalData[country][currentYear]) {
              console.warn("No data for:", country, "Year:", currentYear);
              updateRadar({});
              return;
          }
          updateRadar(globalData[country][currentYear]);
      }

      function updateRadar(data) {
        radarSvg.selectAll("*").remove();  
        parameters.forEach(param => {
            scales[param] = d3.scaleLinear()
                .domain([
                    0,
                    d3.max(
                        Object.values(globalData).flatMap(countryData =>
                            Object.values(countryData).map(yearData => yearData[param] || 0)
                        )
                    )
                ])
                .range([0, radius]);
    
            console.log(`Scale for ${param}:`, scales[param].domain());
        });
    
        const radarGroup = radarSvg.append("g").attr("transform", `translate(${centerX}, ${centerY})`);
    
        for (let i = 1; i <= 5; i++) {
            radarGroup.append("circle")
                .attr("r", (radius / 5) * i)
                .style("fill", "none")
                .style("stroke", "#aaa");
        }
    
        parameters.forEach((param, i) => {
            const x = radius * Math.cos(angleSlice * i - Math.PI / 2);
            const y = radius * Math.sin(angleSlice * i - Math.PI / 2);
    
            radarGroup.append("line")
                .attr("x1", 0)
                .attr("y1", 0)
                .attr("x2", x)
                .attr("y2", y)
                .style("stroke", "gray");
    
            radarGroup.append("text")
                .attr("x", x * 1.1)
                .attr("y", y * 1.1)
                .style("text-anchor", "middle")
                .style("fill", "black")
                .text(param);
        });
    
        const formattedData = parameters.map(param => ({
            parameter: param,
            value: data[param] || 0 
        }));
    
        console.log("Formatted Data for Radar Chart:", formattedData);
    
        radarGroup.append("path")
            .datum(formattedData)
            .attr("d", radarLine)
            .style("fill", "lightblue")
            .style("stroke", "blue")
            .style("opacity", 0.7);
    }

      yearSlider.on("input", function () {
          currentYear = this.value;
          yearDisplay.text(currentYear);
          if (selectedCountry) {
              updateRadarCountry(selectedCountry);
          }
      });

    });

    //Bubble Plot
    const drawBubblePlot = async () => {

      //Load CSVs
      const [livingCosts, renewableEnergy, lifeExpectancy] = await Promise.all([
        d3.csv("Cost_of_Living_and_Income_Extended.csv"),
        d3.csv("global_renewable_energy_production.csv"),
        d3.csv("life_expectancy.csv")
      ]);

      //Pull needed data from datasets
      const totalEnergy = renewableEnergy.map(d => +d['TotalRenewableEnergy']);
      const totalExpectancy = lifeExpectancy.map(d => {
        const value = +d['Life Expectancy World Bank'];
        // Replace zero or invalid values with null
        return (value > 0) ? value : null;
      });
      const co2Values = lifeExpectancy.map(d => +d['CO2']);
      const totalIncome = lifeExpectancy.map(d => d['IncomeGroup']);

      //Merge the data arrays by index
      const mergedData = totalEnergy.map((energy, index) => {
        return {
          TotalRenewableEnergy: energy,
          LifeExpectancy: totalExpectancy[index],
          CO2: co2Values[index],
          IncomeGroup: totalIncome[index]
        };})
        //Need to filter out bad life expectancy values
        .filter(d => d.LifeExpectancy !== null 
        && !isNaN(d.LifeExpectancy) 
        && d.LifeExpectancy > 0 
        && !isNaN(d.TotalRenewableEnergy)
      );

      //Create chart dimensions
      const width = 1200;
      const height = 600;
      const margins = { top: 50, right: 150, bottom: 100, left: 100 };
      const chartWidth = width - margins.left - margins.right;
      const chartHeight = height - margins.top - margins.bottom;

      //Create SVG
      const svg = d3.select("#bubble-chart")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height);

      const chartArea = svg.append('g')
                          .attr('transform', `translate(${margins.left},${margins.top})`);

      //Designate scales for axes
      const xExtent = d3.extent(mergedData, d => d.TotalRenewableEnergy);
      const xScale = d3.scaleLinear()
                      .domain(xExtent)
                      .range([0, chartWidth]);

      const yExtent = d3.extent(mergedData, d => d.LifeExpectancy);
      const yScale = d3.scaleLinear()
                      .domain(yExtent)
                      .range([chartHeight, 0]);

      console.log(yExtent)

      //Designate scales for size and color variables
      const sizeExtent = d3.extent(mergedData, d => d.CO2);
      const sizeScale = d3.scaleLinear()
                          .domain(sizeExtent)
                          .range([2, 15]);

      const colorScale = d3.scaleOrdinal()
                          .domain(mergedData.map(d => d.IncomeGroup))
                          .range(["#DA3D2E", "#FFC845", "#1233A6", "#006F49"]);

      //Append the axes
      const leftAxis = d3.axisLeft(yScale);
      svg.append("g")
        .attr("class", "y axis")
        .attr("transform", `translate(${margins.left}, ${margins.top})`)
        .call(leftAxis);

      const bottomAxis = d3.axisBottom(xScale);
      svg.append("g")
        .attr("class", "x axis")
        .attr("transform", `translate(${margins.left}, ${height - margins.bottom})`)
        .call(bottomAxis);

      //Append the gridlines
      const leftGridlines = d3.axisLeft(yScale).tickFormat('').tickSize(-chartWidth);
      chartArea.append("g")
        .attr("class", "y gridlines")
        .call(leftGridlines);

      const bottomGridlines = d3.axisBottom(xScale).tickFormat('').tickSize(-chartHeight).ticks(6);
      chartArea.append("g")
        .attr("class", "x gridlines")
        .attr("transform", `translate(0, ${chartHeight})`)
        .call(bottomGridlines);

      //Add the y-axis label
      svg.append("text")
        .attr("class", "y label")
        .attr("text-anchor", "middle")
        .attr("font-weight", "bold")
        .attr("x", margins.left / 2)
        .attr("y", height / 2)
        .attr("transform", `rotate(-90, ${margins.left / 2}, ${height / 2})`)
        .text("Life Expectancy (Years)");

      //Add the x-axis label
      svg.append("text")
        .attr("class", "x label")
        .attr("text-anchor", "middle")
        .attr("font-weight", "bold")
        .attr("x", width / 2)
        .attr("y", height - 30)
        .text("Total Renewable Energy (GWh)");

      //Append the circles
      let circles = chartArea.selectAll("circle").data(mergedData)
                            .enter()
                            .append("circle")
                            .attr("cx", d => xScale(d.TotalRenewableEnergy))
                            .attr("cy", d => yScale(d.LifeExpectancy))
                            .attr("r", d => sizeScale(d.CO2) * 2)
                            .attr("fill", d => colorScale(d.IncomeGroup))
                            .attr("opacity", 0.7);

      //Create legend
      const legendWidth = (width - margins.right - margins.left) * 0.14;
      const legendHeight = 250;
      const legendX = width - margins.right + 10;
      const legendY = margins.top;

      //Legend background box
      const legendBox = svg.append("rect")
                          .attr("x", legendX)
                          .attr("y", legendY)
                          .attr("width", legendWidth)
                          .attr("height", legendHeight)
                          .attr("class", "legend-box")
                          .style("fill", "white")
                          .style("stroke", "black");

      //Legend title for Income Groups
      svg.append("text")
          .attr("x", legendX + legendWidth / 2)
          .attr("y", legendY + 20)
          .attr("text-anchor", "middle")
          .attr("font-weight", "bold")
          .text("Income Groups");

      //Append income group color indicators
      svg.append("circle")
        .attr("cx", legendX + 20) 
        .attr("cy", legendY + 20 + 1 * 25)
        .attr("r", 10)
        .attr("fill", "#006F49");

      svg.append("text")
        .attr("x", legendX + 40) 
        .attr("y", legendY + 20 + 1 * 25) 
        .attr("font-size", "12px")
        .attr("alignment-baseline", "middle")
        .text("High Income");
        
      svg.append("circle")
        .attr("cx", legendX + 20) 
        .attr("cy", legendY + 20 + 4 * 25)
        .attr("r", 10)
        .attr("fill", "#DA3D2E");

      svg.append("text")
        .attr("x", legendX + 40) 
        .attr("y", legendY + 20 + 4 * 25) 
        .attr("font-size", "12px")
        .attr("alignment-baseline", "middle")
        .text("Low Income");

      svg.append("circle")
        .attr("cx", legendX + 20) 
        .attr("cy", legendY + 20 + 3 * 25)
        .attr("r", 10)
        .attr("fill", "#ffc845");

      svg.append("text")
        .attr("x", legendX + 40) 
        .attr("y", legendY + 20 + 3 * 25) 
        .attr("font-size", "12px")
        .attr("alignment-baseline", "middle")
        .text("Low-mid Income");

      svg.append("circle")
        .attr("cx", legendX + 20) 
        .attr("cy", legendY + 20 + 2 * 25)
        .attr("r", 10)
        .attr("fill", "#1233A6");

      svg.append("text")
        .attr("x", legendX + 40) 
        .attr("y", legendY + 20 + 2 * 25) 
        .attr("font-size", "12px")
        .attr("alignment-baseline", "middle")
        .text("Up-mid Income");

      //Append CO2 circle radius indicators
      svg.append("text")
          .attr("x", legendX + legendWidth / 2)
          .attr("y", legendY + 20 + 5.5 * 25)
          .attr("text-anchor", "middle")
          .attr("font-weight", "bold")
          .text("CO2 Value (kT)");

      svg.append("circle")
        .attr("cx", legendX + 13) 
        .attr("cy", legendY + 5 + 8 * 24)
        .attr("r", 6)
        .style("stroke", "black")
        .style("stroke-width", 1.5)
        .attr("fill", "none");

      svg.append("circle")
        .attr("cx", legendX + 46) 
        .attr("cy", legendY + 5 + 8 * 24)
        .attr("r", 16)
        .style("stroke", "black")
        .style("stroke-width", 1.5)
        .attr("fill", "none");

      svg.append("circle")
        .attr("cx", legendX + 99) 
        .attr("cy", legendY + 5 + 8 * 24)
        .attr("r", 26)
        .style("stroke", "black")
        .style("stroke-width", 1.5)
        .attr("fill", "none");

      svg.append("text")
        .attr("x", legendX + 12) 
        .attr("y", legendY + 48 + 8 * 24)
        .attr("font-size", "12px")
        .attr("alignment-baseline", "middle")
        .text("40.369 kT - 81.417 kT");
    }

    //Line Chart
    const drawMultiLineChart = async () => {
        // Load data
        const [renewableEnergyData, lifeExpectancyData] = await Promise.all([
          d3.csv("global_renewable_energy_production.csv"),
          d3.csv("life_expectancy.csv"),
        ]);

        // Parse and preprocess data
        const parseYear = d3.timeParse("%Y");
        const renewableGrouped = d3.group(renewableEnergyData, d => d.Year);
        const renewableCleaned = Array.from(renewableGrouped, ([year, records]) => ({
          year: parseYear(year),
          energy: d3.sum(records, r => +r.TotalRenewableEnergy),
        }));

        const lifeGrouped = d3.group(lifeExpectancyData, d => d.Year);
        const lifeCleaned = Array.from(lifeGrouped, ([year, records]) => ({
          year: parseYear(year),
          lifeExpectancy: d3.mean(records, r => +r["Life Expectancy World Bank"]),
          co2: d3.mean(records, r => +r.CO2),
        }));

        const mergedData = renewableCleaned.map(d => {
          const match = lifeCleaned.find(ld => ld.year.getTime() === d.year.getTime());
          return {
            year: d.year,
            energy: d.energy,
            lifeExpectancy: match ? match.lifeExpectancy : null,
            co2: match ? match.co2 : null,
          };
        }).filter(d => d.lifeExpectancy !== null && d.co2 !== null);


        const width = 1600;
        const height = 700;
        const margins = { top: 60, right: 400, bottom: 60, left: 160 };
        const chartWidth = width - margins.left - margins.right;
        const chartHeight = height - margins.top - margins.bottom;

        // Scales
        const xScale = d3.scaleTime()
          .domain(d3.extent(mergedData, d => d.year))
          .range([0, chartWidth]);

        const yScaleEnergy = d3.scaleLinear()
          .domain([0, d3.max(mergedData, d => d.energy)])
          .range([chartHeight, 0]);

        const yScaleLife = d3.scaleLinear()
          .domain([d3.min(mergedData, d => d.lifeExpectancy), d3.max(mergedData, d => d.lifeExpectancy)])
          .range([chartHeight, 0]);

        const yScaleCO2 = d3.scaleLinear()
          .domain([0, d3.max(mergedData, d => d.co2)])
          .range([chartHeight, 0]);

        // SVG setup
        const svg = d3.select("#chart")
          .append("svg")
          .attr("width", width)
          .attr("height", height);

        const chartArea = svg.append("g")
          .attr("transform", `translate(${margins.left},${margins.top})`);

        // Gridlines
        chartArea.append("g")
          .attr("class", "gridlines-life")

        chartArea.append("g")
          .attr("class", "gridlines-co2")

        // Axes
        chartArea.append("g")
          .attr("class", "y-axis-life")
          .call(d3.axisLeft(yScaleLife).ticks(7).tickPadding(5))
          .selectAll("text")
          .style("font-size", "15px");


        chartArea.append("g")
          .attr("class", "y-axis-co2")
          .attr("transform", `translate(-40,0)`)
          .call(d3.axisLeft(yScaleCO2).ticks(6).tickPadding(5))
          .selectAll("text")
          .style("font-size", "15px");


        chartArea.append("g")
          .attr("class", "y-axis-energy")
          .attr("transform", `translate(${chartWidth},0)`)
          .call(d3.axisRight(yScaleEnergy).ticks(5).tickPadding(5))
          .style("font-size", "15px");


        chartArea.append("g")
          .attr("transform", `translate(0,${chartHeight})`)
          .call(d3.axisBottom(xScale))
          .selectAll("text")
          .style("font-size", "15px")
          .style("fill", "black");

        // Line generators
        const lineEnergy = d3.line()
          .x(d => xScale(d.year))
          .y(d => yScaleEnergy(d.energy));

        const lineLife = d3.line()
          .x(d => xScale(d.year))
          .y(d => yScaleLife(d.lifeExpectancy));

        const lineCO2 = d3.line()
          .x(d => xScale(d.year))
          .y(d => yScaleCO2(d.co2));

        // Function to draw circles
        const drawCircles = (data, xScale, yScale, color, key) => {
          chartArea.selectAll(`circle.${key}`)
            .data(data)
            .enter()
            .append("circle")
            .attr("class", key)
            .attr("cx", d => xScale(d.year))
            .attr("cy", d => yScale(d[key]))
            .attr("r", 6)
            .attr("fill", color)
            .attr("opacity", 0.7); 

        };

        // Draw lines
        chartArea.append("path")
          .datum(mergedData)
          .attr("class", "line")
          .attr("d", lineEnergy)
          .attr("stroke", "#53C44F");

        chartArea.append("path")
          .datum(mergedData)
          .attr("class", "line")
          .attr("d", lineLife)
          .attr("stroke", "#5F9DD4");

        chartArea.append("path")
          .datum(mergedData)
          .attr("class", "line")
          .attr("d", lineCO2)
          .attr("stroke", "ED8D55");

        // Draw circles for each line
        drawCircles(mergedData, xScale, yScaleEnergy, "#53C44F", "energy");
        drawCircles(mergedData, xScale, yScaleLife, "#5F9DD4", "lifeExpectancy");
        drawCircles(mergedData, xScale, yScaleCO2, "#EC5042", "co2");

        const tooltip = d3.select("#tooltip");

        const drawLine = (data, lineGenerator, color, label) => {
          const lineGroup = chartArea.append("g");
          lineGroup.append("path")
            .datum(data)
            .attr("class", "line")
            .attr("d", lineGenerator)
            .attr("stroke", color)
            .style("cursor", "pointer")
            .on("mousemove", (event) => {
              const [x, y] = d3.pointer(event);
              const year = xScale.invert(x);
              const value = yScaleLife.invert(y);
              tooltip.style("display", "block")
                .style("left", `${event.pageX + 15}px`)
                .style("top", `${event.pageY - 15}px`)
                .html(`<b>${label}</b><br>Year: ${Math.round(year.getFullYear())}<br>Value: ${value.toFixed(2)}`);
            })
            .on("mouseout", () => tooltip.style("display", "none"));
        };

        drawLine(mergedData, lineEnergy, "#53C44F", "Renewable Energy");
        drawLine(mergedData, lineLife, "#5F9DD4", "Life Expectancy");
        drawLine(mergedData, lineCO2, "#EC5042", "CO2 Emissions");

        // Axis Labels
      
        svg.append("text")
          .attr("x", -chartHeight / 1.7) 
          .attr("y", margins.left / 5) 
          .attr("class", "axis-label")
          .attr("transform", "rotate(-90)") 
          .style("text-anchor", "middle") 
          .html(`
      <tspan fill="#5F9DD4">Life Expectancy (Yrs)  &nbsp; &nbsp; </tspan>
      <tspan fill="#EC5042">CO</tspan>
      <tspan fill="#EC5042" font-size="150%">₂</tspan>
      <tspan fill="#EC5042" dy="-0.2em"> Emissions (kT)</tspan>
      `);

        // Right Axis Label - Renewable Energy
        svg.append("text")
          .attr("x", 350) 
          .attr("y", -1290)
          .attr("class", "axis-label")
          .attr("transform", "rotate(90)")
          .style("fill", "#53C44F")
          .style("text-anchor", "middle") 
          .text("Renewable Energy (GWh)");


        svg.append("text")
          .attr("x", chartWidth / 1.55)
          .attr("y", height - 10)
          .attr("class", "axis-label")
          .text("Year")
          .style("text-anchor", "middle");

        // Legend
        const legend = svg.append("g")
          .attr("transform", `translate(${chartWidth + 250}, ${margins.top})`)
          .attr("class", "legend");

        legend.append("circle")
          .attr("cx", 0).attr("cy", 10).attr("r", 5).attr("fill", "#53C44F");
        legend.append("text")
          .attr("x", 15).attr("y", 14)
          .text("Total Annual Renewable Energy (GWh)");

        legend.append("circle")
          .attr("cx", 0).attr("cy", 30).attr("r", 5).attr("fill", "#5F9DD4");
        legend.append("text")
          .attr("x", 15).attr("y", 34)
          .text("Life Expectancy (Years)");

        legend.append("circle")
          .attr("cx", 0).attr("cy", 50).attr("r", 5).attr("fill", "#EC5042");
        legend.append("text")
          .attr("x", 15).attr("y", 54)
          .text("CO2 Emissions (kT)");
      };

      //Bar chart
      const RenewableEnergyChart = (function () {
          const svg = d3.select("svg#barchart");
          const width = svg.attr("width");
          const height = svg.attr("height");
          const margin = { top: 10, right: 10, bottom: 50, left: 50 };
          const chartWidth = width - margin.left - margin.right;
          const chartHeight = height - margin.top - margin.bottom;

          const annotations = svg.append("g").attr("id", "annotations");
          const chartArea = svg.append("g").attr("id", "points")
              .attr("transform", `translate(${margin.left}, ${margin.top})`);

          const tooltip = d3.select("#tooltip");

          const color = d3.scaleOrdinal()
              .domain(["SolarEnergy", "WindEnergy", "HydroEnergy", "OtherRenewableEnergy"])
              .range(d3.schemeSpectral[4]);

          let yearData;

          d3.csv('global_renewable_energy_production.csv').then(rawData => {
              rawData.forEach(d => {
                  d.Year = +d.Year;
                  d.SolarEnergy = +d.SolarEnergy;
                  d.WindEnergy = +d.WindEnergy;
                  d.HydroEnergy = +d.HydroEnergy;
                  d.OtherRenewableEnergy = +d.OtherRenewableEnergy;
              });

          yearData = d3.group(rawData, d => d.Year);

          const outputScale = d3.scaleLinear().range([chartHeight, 0]);
          const countryScale = d3.scaleBand().range([0, chartWidth]).padding(0.1);

          const leftAxis = d3.axisLeft(outputScale).ticks(10);
          const leftGridlines = d3.axisLeft(outputScale)
              .tickSize(-chartWidth - 10)
              .tickFormat("");
          annotations.append("g")
              .attr("class", "y gridlines")
              .attr("transform", `translate(${margin.left - 10},${margin.top})`)
              .call(leftGridlines);
          annotations.append("g")
              .attr("class", "y axis")
              .attr("transform", `translate(${margin.left},${margin.top})`)
              .call(leftAxis);
          annotations.append("text")
              .attr("class", "y-axis-label")
              .attr("transform", `translate(${margin.left - 40}, ${margin.top + chartHeight / 2}) rotate(-90)`)
              .style("text-anchor", "middle")
              .style("font-size", "8px")
              .style("fill", "#333")
              .text("(Hundreds of Thousands of MWh)");
          const bottomAxis = d3.axisBottom(countryScale);
          annotations.append("g")
              .attr("class", "x axis")
              .attr("transform", `translate(${margin.left},${chartHeight + margin.top + 10})`)
              .call(bottomAxis);

          function updateBarsAnimated(year) {
              const data = yearData.get(+year);
              const energyTypes = ["SolarEnergy", "WindEnergy", "HydroEnergy", "OtherRenewableEnergy"];
              const stackedData = d3.stack().keys(energyTypes)(data);

              countryScale.domain(data.map(d => d.Country));
              outputScale.domain([0, d3.max(data, d => d.SolarEnergy + d.WindEnergy + d.HydroEnergy + d.OtherRenewableEnergy)]);

              annotations.select(".y.axis")
                  .transition()
                  .call(leftAxis);

              annotations.select(".x.axis")
                  .transition()
                  .call(bottomAxis);

              chartArea.selectAll('g.layer')
                  .data(stackedData)
                  .join(
                      enter => enter.append('g')
                          .attr('class', 'layer')
                          .attr('fill', d => color(d.key))
                          .selectAll('rect')
                          .data(d => d)
                          .enter()
                          .append('rect')
                          .attr("x", d => countryScale(d.data.Country))
                          .attr("y", d => outputScale(d[1]))
                          .attr("height", d => outputScale(d[0]) - outputScale(d[1]))
                          .attr("width", countryScale.bandwidth())
                          .on("mouseover", (event, d) => {
                              const energyType = d3.select(event.target.parentNode).datum().key;
                              tooltip.style("display", "block")
                                  .html(`
                                      <strong>${d.data.Country}</strong><br>
                                      ${energyType}: ${(d[1] - d[0]).toLocaleString()} MWh
                                  `);
                          })
                          .on("mousemove", event => {
                              tooltip.style("top", (event.pageY + 10) + "px")
                                  .style("left", (event.pageX + 10) + "px");
                          })
                          .on("mouseout", () => {
                              tooltip.style("display", "none");
                          }),
                      update => update.selectAll('rect')
                          .data(d => d)
                          .join(
                              enter => enter.append('rect')
                                  .attr("x", d => countryScale(d.data.Country))
                                  .attr("y", d => outputScale(d[1]))
                                  .attr("height", d => outputScale(d[0]) - outputScale(d[1]))
                                  .attr("width", countryScale.bandwidth())
                                  .on("mouseover", (event, d) => {
                                      const energyType = d3.select(event.target.parentNode).datum().key;
                                      tooltip.style("display", "block")
                                          .html(`
                                              <strong>${d.data.Country}</strong><br>
                                              ${energyType}: ${(d[1] - d[0]).toLocaleString()} MWh
                                          `);
                                  })
                                  .on("mousemove", event => {
                                      tooltip.style("top", (event.pageY + 10) + "px")
                                          .style("left", (event.pageX + 10) + "px");
                                  })
                                  .on("mouseout", () => {
                                      tooltip.style("display", "none");
                                  }),
                              update => update.transition()
                                  .attr("x", d => countryScale(d.data.Country))
                                  .attr("y", d => outputScale(d[1]))
                                  .attr("height", d => outputScale(d[0]) - outputScale(d[1]))
                                  .attr("width", countryScale.bandwidth()),
                              exit => exit.transition().remove()
                          ),
                      exit => exit.transition().remove()
                  );
          }

          const years = Array.from(yearData.keys()).sort((a, b) => a - b);
          const buttonBar = d3.select("#button-bar");
          years.forEach(year => {
              buttonBar.append("button")
                  .text(year)
                  .on("click", () => updateBarsAnimated(year));
          });

          const legend = svg.append("g")
              .attr("id", "legend")
              .attr("transform", `translate(${chartWidth - 200}, ${margin.top})`);

          const energyTypes = ["Solar Energy", "Wind Energy", "Hydro Energy", "Other Renewable Energy"];
          legend.selectAll("g")
              .data(energyTypes)
              .join("g")
              .attr("class", "legend-item")
              .attr("transform", (d, i) => `translate(0, ${i * 20})`)
              .each(function (d) {
                  const g = d3.select(this);
                  g.append("rect")
                      .attr("x", 0)
                      .attr("y", 0)
                      .attr("width", 10)
                      .attr("height", 10)
                      .attr("fill", color(d));
                  g.append("text")
                      .attr("x", 25)
                      .attr("y", 14)
                      .text(d)
                      .style("font-size", "14px")
                      .style("fill", "#333");
              });

          // Initial year
          updateBarsAnimated(years[0]);
          });
      });

      drawRadarChart();
      drawMultiLineChart();
      drawBubblePlot();
      RenewableEnergyChart();
  </script>
</body>
</html>
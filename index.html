<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scatter Plot</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
  body {
    font-family: Arial, Helvetica, sans-serif;
    background-color: rgb(255, 255, 255);
    color: rgb(0, 0, 0);
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    font-size: 20px;
    line-height: 1.6;
  }
  p {
    width: 75%; 
    margin-top: 5px;
    margin-bottom: 5px;
    line-height: 1.5;
  }

  #radarChart #map{
    background-color: #333;
  }

  h1 {
    margin-top: 20px;
  }

  h2 {
    margin-top: 20px;
    margin-bottom: 10px;
}

  h3 {
  margin-top: 0px;
  margin-bottom: 20px;
}

  .slider-container {
    margin-top: 10px;
    display: flex;
    align-items: center;
  }

  .slider {
    margin-left: 10px;
  }

  .tooltip {
  position: absolute;
  background-color: white;
  color: black;
  padding: 5px;
  border-radius: 3px;
  font-size: 12px;
  pointer-events: none;
  opacity: 1;
  visibility: visible;
  transition: opacity 0.2s ease-in-out;
}

  .barchartTooltip {
      position: absolute;
      text-align: center;
      background: white;
      border: 1px solid #ddd;
      padding: 5px;
      border-radius: 4px;
      pointer-events: none;
      font-size: 14px;
      display: none; 
  }

  #graph-description {
    margin-left: 0px;
    text-align: center;
  }

  .line {
    fill: none;
    stroke-width: 4px;
  }

  .gridlines line {
    stroke: #bbb;
  }

  .gridlines .domain {
    stroke: none;
  }

  .axis-label {
    font-size: 14px;
    font-weight: bold;
  }

  .y-axis-energy .tick text {
    fill: #53C44F;
    font-size: 14px;
  }

  .y-axis-life .tick text {
    fill: #5F9DD4;
    font-size: 14px;
  }

  .y-axis-co2 .tick text {
    fill: #EC5042;
    font-size: 14px;
  }

  .legend {
    font-family: Arial, sans-serif;
    font-size: 12px;
  }

  .legend-box {
    stroke: #000;
    stroke-width: 1px;
    fill: rgba(255, 255, 255, 0.8);
  }

  #button-bar {
    display: flex;
    flex-wrap: wrap;
    justify-content: center; 
    gap: 5px; 
    max-width: 800px; 
}

  button {
    margin-right: 5px;
    padding: 5px 10px;
    font-size: 14px;
  }

  p {
    color: #000;
  }
  </style>
</head>
<body>
  <h1>Renewable Energy and Quality of Life Correlation</h1>
  <h3>Contributors: Alexander Pirouznia, Carl Chen, Simon Tian, Jason Lee</h3>

  <p>In this project, we combined multiple datasets to create a series of visualization of global socioeconomic and environmental trends.
     We used three data sources, including the Regional Cost of Living Analysis, the World Bank’s Life Expectancy and Socioeconomic 
     Dataset, and Global Renewable Energy Production Data. These datasets provided useful insights into six key indicators: renewable 
     energy production, life expectancy, healthcare spending, CO₂ emissions, cost of living, and average income. The data spans multiple
      years, enabling temporal and spatial analyses of trends and correlations across countries.</p>

  <h2>Dataset Analysis</h2>

  <p><a href="https://www.kaggle.com/datasets/heidarmirhajisadati/regional-cost-of-living-analysis">Regional Cost of Living Analysis:</a> 
    This dataset reflects the cost of living in each country quantitatively, which provides insights into the affordability of goods and 
    services in different countries. It also includes information about average monthly incomes, which enables us to consider a comparison
     of economic well being.<p>

  <p><a href="https://www.kaggle.com/datasets/mjshri23/life-expectancy-and-socio-economic-world-bank">Expectancy and Socioeconomic Data 
    from the World Bank:</a> This dataset provided the team several socioeconomic indicators for the analysis, including average life 
    expectancy, healthcare expenditure, and CO₂ emissions. These metrics are important for understanding the quality of life and 
    environmental impact across different regions, which can be reflected in the visualizations.<p>

  <p><a href="https://www.kaggle.com/datasets/ahmedgaitani/global-renewable-energy">Global Renewable Energy Production Data:</a> This 
    dataset offers a breakdown of renewable energy production by type, including solar, wind, hydro, etc., and the total output per 
    country. The dataset will help us to understand and evaluate the adoption of sustainable energy practices and their socioeconomic 
    implications.
    <p>
  
    <p>To ensure data quality, the team conducted preprocessing. For instance, some of the methods we used include filling-in the missing
       values, removing invalid entries, and metrics normalization. The three datasets were merged into a cohesive format for analysis, 
       especially for the radar diagram. This also allows consistent comparisons across countries and years.</p>

  <h2>Interactive Global Radar Chart</h2>
  <div id="map-container">
  <svg id="map" width="600" height="400"></svg>
  <svg id="radarChart" width="400" height="400"></svg>
  </div>
  <div class="slider-container">
    <label for="yearSlider">Year:</label>
    <input type="range" id="yearSlider" class="slider" min="2000" max="2023" step="1" value="2000">
    <span id="yearDisplay">2000</span>
  </div>
  <div class="tooltip" id="tooltip"></div>
  <div id="barchartTooltip" class="barchartTooltip"></div>

  <p>The world map is the central visualization for illustrating geographically distributed data. The map provides an intuitive and 
    spatially contextualized view of the global data we have, allowing users to identify patterns across countries effectively. Countries
     with available data are highlighted in teal color, while those without data are muted with  a background gray color, which ensures 
     a good visual distinction.  </p>
  
  <p>The interactivity is also a key element of the map. When users hover over a country, a tooltip displays the country name as feedback.
     This interactive element ensures users can identify and explore the precise countries of interest. The hover interaction connects 
     the map to the radar visualization, which reinforces the spatial relevance of the data. The user can also click on the country of 
     interest to maintain their selection, while examining other countries which they might be interested in next. </p>
  
  <p>On the other hand, the radar chart is a complementary visualization to the world map, providing an intuitive and compact way to 
    display multidimensional data for each country. The radar chart allows users to compare multiple metrics simultaneously by focusing 
    on six key indicators: Renewable Energy, Life Expectancy, Healthcare Spending, CO₂ Emissions, Cost of Living, and Average Income. 
    This makes it effective for visualizing categorical or grouped data where traditional charts might struggle to display relationships 
    and trends clearly. Our radar chart can help users quickly identify strengths, weaknesses, and patterns within a country’s data 
    across all six dimensions.

  <p>Since the displayed data is dynamically updated based on the hover interaction on the world map, this interactivity greatly 
    increased the radar chart’s utility as well. When a user selects or hovers over a country, the radar chart will reflect that 
    country’s corresponding data, which is a great user experience. This connection between the world map and radar chart also enables 
    users to contextualize the selected country’s performance in a visually appealing manner. </p>

  <p>The chart uses a clean white theme that matches the overall design, with light blue fill and blue stroke for the data visualization.
     The gridlines and axes are colored in subtle gray to provide visual aid when assessing the data points without overwhelming the 
     visualization. Additionally, the team applied smooth transitions when updating the radar chart to ensure a polished and fluid user 
     experience.</p>

  <p>Finally, a year-slider has been added to the bottom of the world map / radar chart to skim through different years quickly and 
    efficiently. This feature allows the users to accurately select the year of interest, where it also allows the user to drag the 
    slider left and right, to see the change in a particular trend in the radar chart. This is a practical addition when combined with 
    the radar chart, as it can help the user to visualize the data trend more easily. </p>

  </p>
  <h2>CO2 Production, Wealth, and Renewable Energy Use Comparison</h2>
  <div id="bubble-chart"></div>
  <p>This visualization reveals insights into the relationships between wealth, human development, and environmental impact. Life 
    expectancy emerges as a leading indicator of economic prosperity, with a clear gradient across income levels. High-income regions 
    consistently demonstrate life expectancies exceeding 70 years, in contrast to lower-income areas where life expectancy falls below 
    60 years.</p>

  <p>Rather than following a linear progression tied to income, renewable energy usage clusters most densely in the mid-range, spanning 
    approximately 2,000 to 3,500 GWh. This suggests a more nuanced relationship between economic development and sustainable energy 
    adoption, challenging assumptions about wealth and green energy implementation.</p>

  <p>The carbon emissions profile presents another layer of complexity. CO2 levels exhausted from fossil fuel consumption display the 
    most variation at higher income levels, with an amplified footprint compared to lower-income regions. While lower-income areas 
    contribute a minimal carbon emissions signature, the data highlights the disproportionate environmental impact of economies with 
    large wealth gaps.</p>

  <div id="graph-description">
  <h2>Time Series Line Graph</h2>
  </div>

  <div id="chart"></div>
  <div class="tooltip" id="linetooltip"></div>
  <p>The visualization is a time-series line chart comparing CO2 emissions, average life expectancy, and global annual renewable energy 
    production from 2000 to 2020.The x-axis represents time, allowing viewers to track changes over the 20-year period, while the y-axes 
    represent the three variables. The left y-axis is shared between life expectancy and CO2 emissions to conserve space and simplify 
    interpretation, with color coding ensuring clear differentiation. Renewable energy production is placed on a separate right y-axis 
    due to its much larger scale, in order to prevent distortion and maintain accuracy.  </p>

  <p>Color is a key visual tool, with each variable assigned a distinct and meaningful shade: red for CO2 emissions, emphasizing urgency;
     blue for life expectancy, symbolizing health; and green for renewable energy, representing environmental progress. Trends are 
     primarily represented by lines, which allow for smooth tracking over time, while circles mark individual data points to enhance 
     precision and make specific values easily identifiable. Linear scales are used for all axes to preserve proportional relationships 
     and ensure trends are intuitive to interpret.</p>

  <p>The interactive elements of the visualization focus on providing clarity and enhancing user engagement through the use of tooltips 
    and interactive data points. Tooltips are a central feature, appearing when users hover over individual data points along the lines. 
    These tooltips display detailed information, such as the exact values for CO2 emissions, life expectancy, or renewable energy 
    production for a given year. This design decision allows viewers to explore the chart with greater precision, offering immediate, 
    contextual feedback without cluttering the overall visualization. Tooltips are positioned intuitively and styled to remain 
    unobtrusive, ensuring they provide value without overwhelming the user.</p>

  <p>The inclusion of data point markers—represented as circles along the lines—also enhances discoverability and usability. These 
    markers signal to users that the chart is interactive and provide clear targets for hovering. This interaction choice is simple, 
    familiar, and effective for enabling deeper exploration while keeping the visualization clean and focused. By limiting interactions 
    to hover-based tooltips, the design avoids unnecessary complexity and ensures that the chart remains approachable for users of all 
    skill levels.</p>

  <p>Examining the trends of CO2 emissions, global renewable energy production, and life expectancy from 2000 to 2020 reveals a 
    combination of progress and inconsistency. Life expectancy has steadily increased over the two decades, reflecting advancements in 
    healthcare, living conditions, and overall development. However, this positive trajectory contrasts with the persistently high CO2 
    emissions, which have shown little meaningful decline. This suggests that while human well-being has improved, it continues to be 
    supported by fossil fuel reliance, highlighting the environmental costs of global growth.</p>

  <p>The trend in renewable energy production was particularly unexpected. Given the urgency of the climate crisis and the global 
    emphasis on sustainability, I anticipated consistent growth over the years. Instead, the data reveals large fluctuations, with 
    significant increases, such as from 2002 to 2003, followed by notable declines, especially between 2009 and 2011. By 2020, production
     had even fallen below 2000 levels, suggesting an overall lack of sustained progress. These inconsistencies may be due to the 
     weather-dependent nature of renewable energy or variability in infrastructure investment and policy support. Together, these 
     trends show that while life expectancy has seen steady improvement, renewable energy production has not followed a clear upward 
     trajectory, and CO2 emissions remain unchanged, reflecting a complex relationship between development and environmental impact.</p>

  <h2>Renewable Energy Sources by Country</h2>
  <div id="container">
      <svg id="barchart" height="500" width="800" style="background: #ffffff;"></svg>
  </div>
  <div id="button-bar"></div>
  <div id="tooltip" class="tooltip"></div>
  <p>Using the interactive year buttons, we can see that there really is no specific trend between countries or the renewable energy 
    sector with heavy fluctuations from the years 2000 to 2023. There is no dominant country in renewable energy production, the 
    different sectors themselves (wind, solar, hydro, other) waver on a year to year basis. However, we can see that overall renewable 
    energy production is tending to grow on a year by year basis. We believe these fluctuations are testament to the unpredictability 
    of weather that may impede solar, hydro, or wind development. For example, solar production is contingent on there being ample 
    sunlight, and wind production is contingent on there being high wind speeds. Both are unpredictable and uncontrollable.</p>

  <p>If we narrow down our analysis to the last five years, we can analyze a smaller subset that is more directly applicable to modern 
    days. We see within the last five years, that wind and hydro energy usually take up the bulk of renewable energy production. In 
    addition, solar production has been generally increasing, besides for a lull in 2021. Wind energy too, has seen steady growth. Hydro,
     is perhaps the most stable, because it depends the least on the weather due to manmade dams and aqueducts. However, even this too 
     may be reliant on weather forces affecting rain or drought.  Finally, other renewable energies round it out, usually providing a 
     small subset within production due to their gradual diversification within the energy sector mix. </p>
     
  <p>Within a country by country basis, we notice several trends. For one, there is no dominating country in total renewable energy 
      production, although France seems to consistently output high levels of production. All countries seem to perform better than others 
      in specific sectors, and even then that changes on a year to year basis. There are no dominant performances, where a country has led 
      production in all four categories.  Furthermore, China consistently outputs high levels of hydro power production, while Australia 
      consistently outputs high levels of wind power production. </p>
  

  <p>Because of this, if there was one notable thing that could be improved from the visualization it would be the addition of a total 
    energy production bar (with all the countries combined). This could be helpful for the larger picture of each year, to show growth 
    in renewable energy in the grander scope and not only on a country by country basis. This could help a user visualize the larger 
    picture more immediately throughout the years, whereas separating by country may provide a too muddled approach that is hard to 
    grasp the overall changes. </p>

  <h2>Observations and Conclusion</h2>
  <p><b>Socioeconomic Indicators: </b>Countries with higher adoption of renewable energy sources often exhibit better 
    socioeconomic indicators, such as higher life expectancy and average income, coupled with lower CO₂ emissions.</p>

  <p><b>Regional Differences: </b>Low-income regions often face challenges in renewable energy adoption, with corresponding lower 
    socioeconomic outcomes.</p>

  <p><b>Temporal Progress:</b> Over the years, many countries have made significant strides in renewable energy adoption, which often 
    correlates
     with improvements in life expectancy and reductions in CO₂ emissions.</p>

  <p><b>Sustainability Challenges:</b> Some regions with high renewable energy production still face challenges in socioeconomic 
    indicators, 
    highlighting the complexity of achieving sustainability.</p>

  <p>The project provides a powerful tool for exploring global trends and their implications by implementing four effective visualizations
     for data presentation. Policymakers, researchers, and the public can use these visualizations to better understand the connection 
     between socioeconomic factors and environmental sustainability, and to identify opportunities to improve the quality of life and 
     the adaptation of renewable energy globally. </p>
  <script>
    //Radar Graph
    const drawRadarChart = (function () {
      const parameters = ["Renewable", "LifeExpectancy", "Healthcare", "CO2", "CostOfLiving", "AverageIncome"];
      const angleSlice = (Math.PI * 2) / parameters.length;
      const radarWidth = 400, radarHeight = 400, radius = Math.min(radarWidth, radarHeight) / 2 - 50;
      const centerX = radarWidth / 2, centerY = radarHeight / 2;

      const mapSvg = d3.select("#map");
      const radarSvg = d3.select("#radarChart");
      const tooltip = d3.select("#tooltip");
      const yearSlider = d3.select("#yearSlider");
      const yearDisplay = d3.select("#yearDisplay");

      let scales = {};
      let globalData = {};
      let currentYear = "2000";
      let selectedCountry = null; 
      let countries = new Set(); 

      const radarLine = d3.lineRadial()
          .angle((d, i) => i * angleSlice)
          .radius(d => scales[d.parameter](d.value))
          .curve(d3.curveLinearClosed);

      // Load data and GeoJSON
      Promise.all([
          d3.json("global.geo.json"),
          d3.csv("Combined_cleaned_reduced.csv"),
      ]).then(([geoData, combinedData, costOfLiving]) => {
          processData(combinedData, costOfLiving);
          drawMap(geoData);
          updateRadar({}); 
      });

      function processData(combinedData, costOfLiving) {
          combinedData.forEach(d => {
              const country = d.Country;
              const year = d.Year;
              if (!globalData[country]) globalData[country] = {};
              globalData[country][year] = {
                  Renewable: +d.TotalRenewableEnergy || 0,
                  LifeExpectancy: +d.Life_Expect || 0,
                  Healthcare: +d.Health_Expenditure || 0,
                  CO2: +d.CO2 || 0,
                  CostOfLiving: +d.Cost_of_Living || 0,
                  AverageIncome: +d.Average_Monthly_Income || 0
              };
              countries.add(country);
          });
      }

      function drawMap(geoData) {
        const projection = d3.geoMercator().fitSize([600, 400], geoData);
        const path = d3.geoPath().projection(projection);
    
        mapSvg.selectAll("path")
            .data(geoData.features)
            .join("path")
            .attr("d", path)
            .attr("fill", d => countries.has(d.properties.name) ? "#c7f5ff" : "#444")
            .attr("stroke", "black")
            .attr("class", "country")
            .on("mouseover", (event, d) => {
                const country = d.properties.name || "Unknown Country";
                tooltip.style("visibility", "visible")
                    .style("opacity", 1)
                    .text(country);
            })
            .on("mousemove", event => {
                tooltip.style("top", `${event.pageY - 30}px`)
                    .style("left", `${event.pageX + 10}px`);
            })
            .on("mouseout", () => {
                tooltip.style("visibility", "hidden")
                    .style("opacity", 0);
            })
            .on("click", (event, d) => {
                selectedCountry = d.properties.name;
                updateRadarCountry(selectedCountry);
    
                mapSvg.selectAll(".country")
                    .attr("fill", d => {
                        if (d.properties.name === selectedCountry) {
                            return "#ffa500"; // orange highlighting
                        }
                        return countries.has(d.properties.name) ? "#c7f5ff" : "#444";
                    });
            });
    }

      function updateRadarCountry(country) {
          if (!country || !globalData[country] || !globalData[country][currentYear]) {
              console.warn("No data for:", country, "Year:", currentYear);
              updateRadar({});
              return;
          }
          updateRadar(globalData[country][currentYear]);
      }

      function updateRadar(data) {
        radarSvg.selectAll("*").remove();  
        parameters.forEach(param => {
            scales[param] = d3.scaleLinear()
                .domain([
                    0,
                    d3.max(
                        Object.values(globalData).flatMap(countryData =>
                            Object.values(countryData).map(yearData => yearData[param] || 0)
                        )
                    )
                ])
                .range([0, radius]);
    
            console.log(`Scale for ${param}:`, scales[param].domain());
        });
    
        const radarGroup = radarSvg.append("g").attr("transform", `translate(${centerX}, ${centerY})`);
    
        for (let i = 1; i <= 5; i++) {
            radarGroup.append("circle")
                .attr("r", (radius / 5) * i)
                .style("fill", "none")
                .style("stroke", "#aaa");
        }
    
        parameters.forEach((param, i) => {
            const x = radius * Math.cos(angleSlice * i - Math.PI / 2);
            const y = radius * Math.sin(angleSlice * i - Math.PI / 2);
    
            radarGroup.append("line")
                .attr("x1", 0)
                .attr("y1", 0)
                .attr("x2", x)
                .attr("y2", y)
                .style("stroke", "gray");
    
            radarGroup.append("text")
                .attr("x", x * 1.1)
                .attr("y", y * 1.1)
                .style("text-anchor", "middle")
                .style("fill", "black")
                .style("font-size", "12px")
                .text(param);
        });
    
        const formattedData = parameters.map(param => ({
            parameter: param,
            value: data[param] || 0 
        }));
    
        console.log("Formatted Data for Radar Chart:", formattedData);
    
        radarGroup.append("path")
            .datum(formattedData)
            .attr("d", radarLine)
            .style("fill", "lightblue")
            .style("stroke", "blue")
            .style("opacity", 0.7);
    }

      yearSlider.on("input", function () {
          currentYear = this.value;
          yearDisplay.text(currentYear);
          if (selectedCountry) {
              updateRadarCountry(selectedCountry);
          }
      });

    });
    
    ///////////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////////
    //Bubble Plot
    ///////////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////////
    const drawBubblePlot = async () => {

      //Load CSVs
      const [livingCosts, renewableEnergy, lifeExpectancy] = await Promise.all([
        d3.csv("Cost_of_Living_and_Income_Extended.csv"),
        d3.csv("global_renewable_energy_production.csv"),
        d3.csv("life_expectancy.csv")
      ]);

      //Pull needed data from datasets
      const totalEnergy = renewableEnergy.map(d => +d['TotalRenewableEnergy']);
      const totalExpectancy = lifeExpectancy.map(d => {
        const value = +d['Life Expectancy World Bank'];
        // Replace zero or invalid values with null
        return (value > 0) ? value : null;
      });
      const co2Values = lifeExpectancy.map(d => +d['CO2']);
      const totalIncome = lifeExpectancy.map(d => d['IncomeGroup']);

      //Merge the data arrays by index
      const mergedData = totalEnergy.map((energy, index) => {
        return {
          TotalRenewableEnergy: energy,
          LifeExpectancy: totalExpectancy[index],
          CO2: co2Values[index],
          IncomeGroup: totalIncome[index]
        };})
        //Need to filter out bad life expectancy values
        .filter(d => d.LifeExpectancy !== null 
        && !isNaN(d.LifeExpectancy) 
        && d.LifeExpectancy > 0 
        && !isNaN(d.TotalRenewableEnergy)
      );

      //Create chart dimensions
      const width = 1000;
      const height = 600;
      const margins = { top: 50, right: 150, bottom: 100, left: 100 };
      const chartWidth = width - margins.left - margins.right;
      const chartHeight = height - margins.top - margins.bottom;

      //Create SVG
      const svg = d3.select("#bubble-chart")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height);

      const chartArea = svg.append('g')
                          .attr('transform', `translate(${margins.left},${margins.top})`);

      //Designate scales for axes
      const xExtent = d3.extent(mergedData, d => d.TotalRenewableEnergy);
      const xScale = d3.scaleLinear()
                      .domain(xExtent)
                      .range([0, chartWidth]);

      const yExtent = d3.extent(mergedData, d => d.LifeExpectancy);
      const yScale = d3.scaleLinear()
                      .domain(yExtent)
                      .range([chartHeight, 0]);

      console.log(yExtent)

      //Designate scales for size and color variables
      const sizeExtent = d3.extent(mergedData, d => d.CO2);
      const sizeScale = d3.scaleLinear()
                          .domain(sizeExtent)
                          .range([2, 15]);

      const colorScale = d3.scaleOrdinal()
                          .domain(mergedData.map(d => d.IncomeGroup))
                          .range(["#DA3D2E", "#FFC845", "#1233A6", "#006F49"]);

      //Append the axes
      const leftAxis = d3.axisLeft(yScale);
      svg.append("g")
        .attr("class", "y axis")
        .attr("transform", `translate(${margins.left}, ${margins.top})`)
        .call(leftAxis);

      const bottomAxis = d3.axisBottom(xScale);
      svg.append("g")
        .attr("class", "x axis")
        .attr("transform", `translate(${margins.left}, ${height - margins.bottom})`)
        .call(bottomAxis);

      //Append the gridlines
      const leftGridlines = d3.axisLeft(yScale).tickFormat('').tickSize(-chartWidth);
      chartArea.append("g")
        .attr("class", "y gridlines")
        .call(leftGridlines);

      const bottomGridlines = d3.axisBottom(xScale).tickFormat('').tickSize(-chartHeight).ticks(6);
      chartArea.append("g")
        .attr("class", "x gridlines")
        .attr("transform", `translate(0, ${chartHeight})`)
        .call(bottomGridlines);

      //Add the y-axis label
      svg.append("text")
        .attr("class", "y label")
        .attr("text-anchor", "middle")
        .attr("font-weight", "bold")
        .attr("x", margins.left / 2)
        .attr("y", height / 2)
        .attr("transform", `rotate(-90, ${margins.left / 2}, ${height / 2})`)
        .text("Life Expectancy (Years)");

      //Add the x-axis label
      svg.append("text")
        .attr("class", "x label")
        .attr("text-anchor", "middle")
        .attr("font-weight", "bold")
        .attr("x", width / 2)
        .attr("y", height - 30)
        .text("Total Renewable Energy (GWh)");

      //Append the circles
      let circles = chartArea.selectAll("circle").data(mergedData)
                            .enter()
                            .append("circle")
                            .attr("cx", d => xScale(d.TotalRenewableEnergy))
                            .attr("cy", d => yScale(d.LifeExpectancy))
                            .attr("r", d => sizeScale(d.CO2) * 2)
                            .attr("fill", d => colorScale(d.IncomeGroup))
                            .attr("opacity", 0.7);

      //Create legend
      const legendWidth = (width - margins.right - margins.left) * 0.18;
      const legendHeight = 250;
      const legendX = width - margins.right + 10;
      const legendY = margins.top;

      //Legend background box
      const legendBox = svg.append("rect")
                          .attr("x", legendX)
                          .attr("y", legendY)
                          .attr("width", legendWidth)
                          .attr("height", legendHeight)
                          .attr("class", "legend-box")
                          .style("fill", "white")
                          .style("stroke", "black");

      //Legend title for Income Groups
      svg.append("text")
        .attr("x", legendX + legendWidth / 2)
        .attr("y", legendY + 20)
        .attr("text-anchor", "middle")
        .attr("font-weight", "bold")
        .style("font-size", "12px") // Correct way to set font size
        .text("Income Groups");

      //Append income group color indicators
      svg.append("circle")
        .attr("cx", legendX + 20) 
        .attr("cy", legendY + 20 + 1 * 25)
        .attr("r", 10)
        .attr("fill", "#006F49");

      svg.append("text")
        .attr("x", legendX + 40) 
        .attr("y", legendY + 20 + 1 * 25) 
        .attr("font-size", "12px")
        .attr("alignment-baseline", "middle")
        .text("High Income");
        
      svg.append("circle")
        .attr("cx", legendX + 20) 
        .attr("cy", legendY + 20 + 4 * 25)
        .attr("r", 10)
        .attr("fill", "#DA3D2E");

      svg.append("text")
        .attr("x", legendX + 40) 
        .attr("y", legendY + 20 + 4 * 25) 
        .attr("font-size", "12px")
        .attr("alignment-baseline", "middle")
        .text("Low Income");

      svg.append("circle")
        .attr("cx", legendX + 20) 
        .attr("cy", legendY + 20 + 3 * 25)
        .attr("r", 10)
        .attr("fill", "#ffc845");

      svg.append("text")
        .attr("x", legendX + 40) 
        .attr("y", legendY + 20 + 3 * 25) 
        .attr("font-size", "12px")
        .attr("alignment-baseline", "middle")
        .text("Low-mid Income");

      svg.append("circle")
        .attr("cx", legendX + 20) 
        .attr("cy", legendY + 20 + 2 * 25)
        .attr("r", 10)
        .attr("fill", "#1233A6");

      svg.append("text")
        .attr("x", legendX + 40) 
        .attr("y", legendY + 20 + 2 * 25) 
        .attr("font-size", "12px")
        .attr("alignment-baseline", "middle")
        .text("Up-mid Income");

      //Append CO2 circle radius indicators
      svg.append("text")
          .attr("x", legendX + legendWidth / 2)
          .attr("y", legendY + 20 + 5.5 * 25)
          .attr("text-anchor", "middle")
          .attr("font-weight", "bold")
          .style("font-size", "12px")
          .text("CO2 Value (kT)");

      svg.append("circle")
        .attr("cx", legendX + 13) 
        .attr("cy", legendY + 5 + 8 * 24)
        .attr("r", 6)
        .style("stroke", "black")
        .style("stroke-width", 1.5)
        .attr("fill", "none");

      svg.append("circle")
        .attr("cx", legendX + 46) 
        .attr("cy", legendY + 5 + 8 * 24)
        .attr("r", 16)
        .style("stroke", "black")
        .style("stroke-width", 1.5)
        .attr("fill", "none");

      svg.append("circle")
        .attr("cx", legendX + 99) 
        .attr("cy", legendY + 5 + 8 * 24)
        .attr("r", 26)
        .style("stroke", "black")
        .style("stroke-width", 1.5)
        .attr("fill", "none");

      svg.append("text")
        .attr("x", legendX + 12) 
        .attr("y", legendY + 48 + 8 * 24)
        .attr("font-size", "12px")
        .attr("alignment-baseline", "middle")
        .text("40.369 kT - 81.417 kT");
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////////
    //Line Chart
    ///////////////////////////////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////////////////////////////
    const drawMultiLineChart = async () => {
        // Load data
        const [renewableEnergyData, lifeExpectancyData] = await Promise.all([
          d3.csv("global_renewable_energy_production.csv"),
          d3.csv("life_expectancy.csv"),
        ]);

        // Parse and preprocess data
        const parseYear = d3.timeParse("%Y");
        const renewableGrouped = d3.group(renewableEnergyData, d => d.Year);
        const renewableCleaned = Array.from(renewableGrouped, ([year, records]) => ({
          year: parseYear(year),
          energy: d3.sum(records, r => +r.TotalRenewableEnergy),
        }));

        const lifeGrouped = d3.group(lifeExpectancyData, d => d.Year);
        const lifeCleaned = Array.from(lifeGrouped, ([year, records]) => ({
          year: parseYear(year),
          lifeExpectancy: d3.mean(records, r => +r["Life Expectancy World Bank"]),
          co2: d3.mean(records, r => +r.CO2),
        }));

        const mergedData = renewableCleaned.map(d => {
          const match = lifeCleaned.find(ld => ld.year.getTime() === d.year.getTime());
          return {
            year: d.year,
            energy: d.energy,
            lifeExpectancy: match ? match.lifeExpectancy : null,
            co2: match ? match.co2 : null,
          };
        }).filter(d => d.lifeExpectancy !== null && d.co2 !== null);


        const width = 1200;
        const height = 600;
        const margins = { top: 60, right: 200, bottom: 60, left: 300 };
        const chartWidth = width - margins.left - margins.right;
        const chartHeight = height - margins.top - margins.bottom;

        // Scales
        const xScale = d3.scaleTime()
          .domain(d3.extent(mergedData, d => d.year))
          .range([0, chartWidth]);

        const yScaleEnergy = d3.scaleLinear()
          .domain([0, d3.max(mergedData, d => d.energy)])
          .range([chartHeight, 0]);

        const yScaleLife = d3.scaleLinear()
          .domain([d3.min(mergedData, d => d.lifeExpectancy), d3.max(mergedData, d => d.lifeExpectancy)])
          .range([chartHeight, 0]);

        const yScaleCO2 = d3.scaleLinear()
          .domain([0, d3.max(mergedData, d => d.co2)])
          .range([chartHeight, 0]);

        // SVG setup
        const svg = d3.select("#chart")
          .append("svg")
          .attr("width", width)
          .attr("height", height);

        const chartArea = svg.append("g")
          .attr("transform", `translate(${margins.left},${margins.top})`);

        // Gridlines
        chartArea.append("g")
          .attr("class", "gridlines-life")

        chartArea.append("g")
          .attr("class", "gridlines-co2")

        // Axes
        chartArea.append("g")
          .attr("class", "y-axis-life")
          .call(d3.axisLeft(yScaleLife).ticks(7).tickPadding(5))
          .selectAll("text")
          .style("font-size", "15px");


        chartArea.append("g")
          .attr("class", "y-axis-co2")
          .attr("transform", `translate(-40,0)`)
          .call(d3.axisLeft(yScaleCO2).ticks(6).tickPadding(5))
          .selectAll("text")
          .style("font-size", "15px");


        chartArea.append("g")
          .attr("class", "y-axis-energy")
          .attr("transform", `translate(${chartWidth},0)`)
          .call(d3.axisRight(yScaleEnergy).ticks(5).tickPadding(5))
          .style("font-size", "15px");


        chartArea.append("g")
          .attr("transform", `translate(0,${chartHeight})`)
          .call(d3.axisBottom(xScale))
          .selectAll("text")
          .style("font-size", "15px")
          .style("fill", "black");

        // Line generators
        const lineEnergy = d3.line()
          .x(d => xScale(d.year))
          .y(d => yScaleEnergy(d.energy));

        const lineLife = d3.line()
          .x(d => xScale(d.year))
          .y(d => yScaleLife(d.lifeExpectancy));

        const lineCO2 = d3.line()
          .x(d => xScale(d.year))
          .y(d => yScaleCO2(d.co2));

        // Function to draw circles
        const drawCircles = (data, xScale, yScale, color, key) => {
          chartArea.selectAll(`circle.${key}`)
            .data(data)
            .enter()
            .append("circle")
            .attr("class", key)
            .attr("cx", d => xScale(d.year))
            .attr("cy", d => yScale(d[key]))
            .attr("r", 6)
            .attr("fill", color)
            .attr("opacity", 0.7); 

        };

        // Draw lines
        chartArea.append("path")
          .datum(mergedData)
          .attr("class", "line")
          .attr("d", lineEnergy)
          .attr("stroke", "#53C44F");

        chartArea.append("path")
          .datum(mergedData)
          .attr("class", "line")
          .attr("d", lineLife)
          .attr("stroke", "#5F9DD4");

        chartArea.append("path")
          .datum(mergedData)
          .attr("class", "line")
          .attr("d", lineCO2)
          .attr("stroke", "ED8D55");

        // Draw circles for each line
        drawCircles(mergedData, xScale, yScaleEnergy, "#53C44F", "energy");
        drawCircles(mergedData, xScale, yScaleLife, "#5F9DD4", "lifeExpectancy");
        drawCircles(mergedData, xScale, yScaleCO2, "#EC5042", "co2");

        const tooltip = d3.select("#linetooltip");

        const drawLine = (data, lineGenerator, color, label) => {
          const lineGroup = chartArea.append("g");
          lineGroup.append("path")
            .datum(data)
            .attr("class", "line")
            .attr("d", lineGenerator)
            .attr("stroke", color)
            .style("cursor", "pointer")
            .on("mousemove", (event) => {
            const [x, y] = d3.pointer(event);
            const year = xScale.invert(x);
            const value = yScaleLife.invert(y);
            tooltip
              .style("opacity", "1")
              .style("left", `${event.pageX + 15}px`)
              .style("top", `${event.pageY - 15}px`)
              .html(`<b>${label}</b><br>Year: ${Math.round(year.getFullYear())}<br>Value: ${value.toFixed(2)}`);
          })
          .on("mouseout", () => tooltip.style("opacity", "0"));
        };

        drawLine(mergedData, lineEnergy, "#53C44F", "Renewable Energy");
        drawLine(mergedData, lineLife, "#5F9DD4", "Life Expectancy");
        drawLine(mergedData, lineCO2, "#EC5042", "CO2 Emissions");

        // Axis Labels
      
        svg.append("text")
          .attr("x", -(chartHeight / 1.7))
          .attr("y", margins.left / 2) 
          .attr("class", "axis-label")
          .attr("transform", "rotate(-90)")
          .style("text-anchor", "middle")
          .html(`
            <tspan fill="#5F9DD4">Life Expectancy (Yrs) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </tspan>
            <tspan fill="#EC5042">CO</tspan>
            <tspan fill="#EC5042" font-size="150%">₂</tspan>
            <tspan fill="#EC5042" dy="-0.2em"> Emissions (kT)</tspan>
          `);

        // Right Axis Label - Renewable Energy
        svg.append("text")
          .attr("x", width - margins.right / 2) 
          .attr("y", margins.top + chartHeight / 2) 
          .attr("class", "axis-label")
          .attr("transform", `rotate(90, ${width - margins.right / 2}, ${margins.top + chartHeight / 2})`) 
          .style("fill", "#53C44F")
          .style("text-anchor", "middle") 
          .text("Renewable Energy (GWh)");


          svg.append("text")
          .attr("x", chartWidth / 2 + margins.left)
          .attr("y", height - margins.bottom / 5)
          .attr("class", "axis-label")
          .style("font-size", "18px")
          .style("text-anchor", "middle")
          .text("Year");

        // Legend
        const legend = svg.append("g")
          .attr("transform", `translate(${width / 2 - 200}, ${margins.top / 2})`) //Center
          .attr("class", "legend");

        legend.append("circle")
          .attr("cx", -100)
          .attr("cy", 0)
          .attr("r", 5)
          .attr("fill", "#53C44F");

        legend.append("text")
          .attr("x", -90)
          .attr("y", 5)
          .attr("font-size", "16px")
          .text("Total Annual Renewable Energy (GWh)");

        legend.append("circle")
          .attr("cx", 220)
          .attr("cy", 0)
          .attr("r", 5)
          .attr("fill", "#5F9DD4");

        legend.append("text")
          .attr("x", 230)
          .attr("y", 5)
          .attr("font-size", "16px")
          .text("Life Expectancy (Years)");

        legend.append("circle")
          .attr("cx", 430)
          .attr("cy", 0)
          .attr("r", 5)
          .attr("fill", "#EC5042");

        legend.append("text")
          .attr("x", 440) 
          .attr("y", 5)
          .attr("font-size", "16px")
          .text("CO2 Emissions (kT)");
        };


      ////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////
      //Bar chart
      ////////////////////////////////////////////////////////////////////
      ////////////////////////////////////////////////////////////////////
      const RenewableEnergyChart = (function () {
          const svg = d3.select("svg#barchart");
          const width = svg.attr("width");
          const height = svg.attr("height");
          const margin = { top: 50, right: 10, bottom: 50, left: 50 };
          const chartWidth = width - margin.left - margin.right;
          const chartHeight = height - margin.top - margin.bottom;

          const annotations = svg.append("g").attr("id", "annotations");
          const chartArea = svg.append("g").attr("id", "points")
              .attr("transform", `translate(${margin.left}, ${margin.top})`);

          const tooltip = d3.select("#barchartTooltip");

          const color = d3.scaleOrdinal()
              .domain(["SolarEnergy", "WindEnergy", "HydroEnergy", "OtherRenewableEnergy"])
              .range(d3.schemeSpectral[4]);

          let yearData;

          d3.csv('global_renewable_energy_production.csv').then(rawData => {
              rawData.forEach(d => {
                  d.Year = +d.Year;
                  d.SolarEnergy = +d.SolarEnergy;
                  d.WindEnergy = +d.WindEnergy;
                  d.HydroEnergy = +d.HydroEnergy;
                  d.OtherRenewableEnergy = +d.OtherRenewableEnergy;
              });

          yearData = d3.group(rawData, d => d.Year);

          const outputScale = d3.scaleLinear().range([chartHeight, 0]);

          const countryScale = d3.scaleBand().range([0, chartWidth]).padding(0.1);

          const leftAxis = d3.axisLeft(outputScale).ticks(10);
          const leftGridlines = d3.axisLeft(outputScale)
              .ticks(10)
              .tickSize(-chartWidth)
              .tickFormat("");

          annotations.append("g")
              .attr("class", "y gridlines")
              .attr("transform", `translate(${margin.left},${margin.top})`)
              .call(leftGridlines);

          annotations.append("g")
              .attr("class", "y axis")
              .attr("transform", `translate(${margin.left},${margin.top})`)
              .call(leftAxis)

          annotations.append("text")
              .attr("class", "y-axis-label")
              .attr("transform", `translate(${margin.left - 40}, ${margin.top + chartHeight / 2}) rotate(-90)`)
              .style("text-anchor", "middle")
              .style("font-size", "16px")
              .style("fill", "#333")
              .text("(Hundreds of Thousands of MWh)");

          const bottomAxis = d3.axisBottom(countryScale);

          annotations.append("g")
              .attr("class", "x axis")
              .attr("transform", `translate(${margin.left},${chartHeight + margin.top + 10})`)
              .attr("font-size", "16px")
              .call(bottomAxis);

          annotations.append("text")
              .attr("class", "x-axis-label")
              .attr("x", margin.left + chartWidth / 2)
              .attr("y", chartHeight + margin.top + 50)
              .style("text-anchor", "middle")
              .style("font-size", "16px")
              .text("Countries");

          function updateBarsAnimated(year) {
              const data = yearData.get(+year);
              const energyTypes = ["SolarEnergy", "WindEnergy", "HydroEnergy", "OtherRenewableEnergy"];
              const stackedData = d3.stack().keys(energyTypes)(data);

              countryScale.domain(data.map(d => d.Country));
              outputScale.domain([0, d3.max(data, d => d.SolarEnergy + d.WindEnergy + d.HydroEnergy + d.OtherRenewableEnergy)]);

              annotations.select(".y.axis")
                  .transition()
                  .call(leftAxis);

              annotations.select(".x.axis")
                  .transition()
                  .call(bottomAxis);

              chartArea.selectAll('g.layer')
                  .data(stackedData)
                  .join(
                      enter => enter.append('g')
                          .attr('class', 'layer')
                          .attr('fill', d => color(d.key))
                          .selectAll('rect')
                          .data(d => d)
                          .enter()
                          .append('rect')
                          .attr("x", d => countryScale(d.data.Country))
                          .attr("y", d => outputScale(d[1]))
                          .attr("height", d => outputScale(d[0]) - outputScale(d[1]))
                          .attr("width", countryScale.bandwidth())
                          .on("mouseover", (event, d) => {
                            console.log("Mouseover triggered for", d);
                            const energyType = d3.select(event.target.parentNode).datum().key;
                            tooltip.style("display", "block")
                                .html(`
                                    <strong>${d.data.Country}</strong><br>
                                    ${energyType}: ${(d[1] - d[0]).toLocaleString()} MWh
                                `);
                        })
                          .on("mousemove", event => {
                              tooltip.style("top", (event.pageY + 10) + "px")
                                  .style("left", (event.pageX + 10) + "px");
                          })
                          .on("mouseout", () => {
                              tooltip.style("display", "none");
                          }),
                      update => update.selectAll('rect')
                          .data(d => d)
                          .join(
                              enter => enter.append('rect')
                                  .attr("x", d => countryScale(d.data.Country))
                                  .attr("y", d => outputScale(d[1]))
                                  .attr("height", d => outputScale(d[0]) - outputScale(d[1]))
                                  .attr("width", countryScale.bandwidth())
                                  .on("mouseover", (event, d) => {
                                      const energyType = d3.select(event.target.parentNode).datum().key;
                                      tooltip.style("display", "block")
                                          .html(`
                                              <strong>${d.data.Country}</strong><br>
                                              ${energyType}: ${(d[1] - d[0]).toLocaleString()} MWh
                                          `);
                                  })
                                  .on("mousemove", event => {
                                      tooltip.style("top", (event.pageY + 10) + "px")
                                          .style("left", (event.pageX + 10) + "px");
                                  })
                                  .on("mouseout", () => {
                                      tooltip.style("display", "none");
                                  }),
                              update => update.transition()
                                  .attr("x", d => countryScale(d.data.Country))
                                  .attr("y", d => outputScale(d[1]))
                                  .attr("height", d => outputScale(d[0]) - outputScale(d[1]))
                                  .attr("width", countryScale.bandwidth()),
                              exit => exit.transition().remove()
                          ),
                      exit => exit.transition().remove()
                  );
          }

          const years = Array.from(yearData.keys()).sort((a, b) => a - b);
          const buttonBar = d3.select("#button-bar");
          years.forEach(year => {
              buttonBar.append("button")
                  .text(year)
                  .on("click", () => updateBarsAnimated(year));
          });

          const legend = svg.append("g")
              .attr("id", "legend")
              .attr("transform", `translate(${chartWidth / 2 - 200}, ${margin.top - 15})`);

          const energyTypes = ["Solar Energy", "Wind Energy", "Hydro Energy", "Other Renewable Energy"];
          const legendSpacing = 120;

          legend.selectAll("g")
              .data(energyTypes)
              .join("g")
              .attr("class", "legend-item")
              .attr("transform", (d, i) => `translate(${i * legendSpacing}, 0)`)
              .each(function (d) {
                  const g = d3.select(this);
                  g.append("rect")
                      .attr("x", 0)
                      .attr("y", -10)
                      .attr("width", 10)
                      .attr("height", 10)
                      .attr("fill", color(d));
                  g.append("text")
                      .attr("x", 15)
                      .attr("y", 0)
                      .text(d)
                      .style("font-size", "14px")
                      .style("fill", "#333");
              });

          // Initial year
          updateBarsAnimated(years[0]);
          });
      });

      drawRadarChart();
      drawMultiLineChart();
      drawBubblePlot();
      RenewableEnergyChart();
  </script>
</body>
</html>
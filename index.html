<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scatter Plot</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
  body {
    font-family: Arial, Helvetica, sans-serif;
    background-color: rgb(255, 255, 255);
    color: rgb(189, 189, 189);
    margin: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  #radarChart #map{
    background-color: #333;
  }

  h1 {
    margin-top: 20px;
  }

  .slider-container {
    margin-top: 10px;
    display: flex;
    align-items: center;
  }

  .slider {
    margin-left: 10px;
  }

  .tooltip {
    position: absolute;
    text-align: center;
    background: white;
    border: 1px solid #ddd;
    padding: 5px;
    border-radius: 4px;
    pointer-events: none;
    font-size: 14px;
    display: none; /* From second code block */
    visibility: hidden; /* From first code block */
  }

  #graph-description {
    margin-left: 200px;
  }

  .line {
    fill: none;
    stroke-width: 4px;
  }

  .gridlines line {
    stroke: #bbb;
  }

  .gridlines .domain {
    stroke: none;
  }

  .axis-label {
    font-size: 14px;
    font-weight: bold;
  }

  .y-axis-energy .tick text {
    fill: #53C44F;
    font-size: 14px;
  }

  .y-axis-life .tick text {
    fill: #5F9DD4;
    font-size: 14px;
  }

  .y-axis-co2 .tick text {
    fill: #EC5042;
    font-size: 14px;
  }

  .legend {
    font-family: Arial, sans-serif;
    font-size: 12px;
  }

  .legend-box {
    stroke: #000;
    stroke-width: 1px;
    fill: rgba(255, 255, 255, 0.8);
  }

  #button-bar {
    margin-top: 10px;
  }

  button {
    margin-right: 5px;
    padding: 5px 10px;
    font-size: 14px;
  }
  </style>
</head>
<body>
  <h2>CO2 Production, Wealth, and Renewable Energy Use Comparison</h2>
  <div id="bubble-chart"></div>

  <div id="graph-description">
      <h2>Time Series Line Graph</h2>
      <p class= "subheader">Analyzing the Relationship Between Life Expectancy, CO2 Emissions, and Global Annual Renewable Energy
      Production (2000–2020)</p>
  </div>
  <div id="chart"></div>
  <div class="tooltip" id="tooltip"></div>

  <h2>Renewable Energy Sources by Country</h2>
  <div id="container">
      <svg id="barchart" height="600" width="900" style="background: #F5F5F5;"></svg>
  </div>
  <div id="button-bar"></div>
  <div id="tooltip" class="tooltip"></div>

  <h2>Interactive Global Radar Chart</h2>
  <div id="map-container">
  <svg id="map" width="800" height="500"></svg>
  <svg id="radarChart" width="500" height="500"></svg>
  </div>
  <div class="slider-container">
    <label for="yearSlider">Year:</label>
    <input type="range" id="yearSlider" class="slider" min="2000" max="2023" step="1" value="2000">
    <span id="yearDisplay">2000</span>
  </div>
  <div class="tooltip" id="tooltip"></div>

  <script>
    //Radar Graph
    const drawRadarChart = (function () {
      const parameters = ["Renewable", "LifeExpectancy", "Healthcare", "CO2", "CostOfLiving", "AverageIncome"];
      const angleSlice = (Math.PI * 2) / parameters.length;
      const radarWidth = 500, radarHeight = 500, radius = Math.min(radarWidth, radarHeight) / 2 - 50;
      const centerX = radarWidth / 2, centerY = radarHeight / 2;

      const mapSvg = d3.select("#map");
      const radarSvg = d3.select("#radarChart");
      const tooltip = d3.select("#tooltip");
      const yearSlider = d3.select("#yearSlider");
      const yearDisplay = d3.select("#yearDisplay");

      let scales = {};
      let globalData = {};
      let currentYear = "2000";
      let selectedCountry = null; 
      let countries = new Set(); 

      const radarLine = d3.lineRadial()
          .angle((d, i) => i * angleSlice)
          .radius(d => scales[d.parameter](d.value))
          .curve(d3.curveLinearClosed);

      // Load data and GeoJSON
      Promise.all([
          d3.json("global.geo.json"),
          d3.csv("Combined_cleaned_reduced.csv"),
      ]).then(([geoData, combinedData, costOfLiving]) => {
          processData(combinedData, costOfLiving);
          drawMap(geoData);
          updateRadar({}); 
      });

      function processData(combinedData, costOfLiving) {
          combinedData.forEach(d => {
              const country = d.Country;
              const year = d.Year;
              if (!globalData[country]) globalData[country] = {};
              globalData[country][year] = {
                  Renewable: +d.TotalRenewableEnergy || 0,
                  LifeExpectancy: +d.Life_Expect || 0,
                  Healthcare: +d.Health_Expenditure || 0,
                  CO2: +d.CO2 || 0,
                  CostOfLiving: +d.Cost_of_Living || 0,
                  AverageIncome: +d.Average_Monthly_Income || 0
              };
              countries.add(country);
          });
      }

      function drawMap(geoData) {
        const projection = d3.geoMercator().fitSize([800, 500], geoData);
        const path = d3.geoPath().projection(projection);
    
        mapSvg.selectAll("path")
            .data(geoData.features)
            .join("path")
            .attr("d", path)
            .attr("fill", d => countries.has(d.properties.name) ? "#c7f5ff" : "#444")
            .attr("stroke", "white")
            .attr("class", "country")
            .on("mouseover", (event, d) => {
                const country = d.properties.name;
                tooltip.style("visibility", "visible").text(country);
            })
            .on("mousemove", event => {
                tooltip.style("top", (event.pageY - 20) + "px")
                      .style("left", (event.pageX + 10) + "px");
            })
            .on("mouseout", () => {
                tooltip.style("visibility", "hidden");
            })
            .on("click", (event, d) => {
                selectedCountry = d.properties.name;
                updateRadarCountry(selectedCountry);
    
                mapSvg.selectAll(".country")
                    .attr("fill", d => {
                        if (d.properties.name === selectedCountry) {
                            return "#ffa500"; // orange highlighting
                        }
                        return countries.has(d.properties.name) ? "#c7f5ff" : "#444";
                    });
            });
    }

      function updateRadarCountry(country) {
          if (!country || !globalData[country] || !globalData[country][currentYear]) {
              console.warn("No data for:", country, "Year:", currentYear);
              updateRadar({});
              return;
          }
          updateRadar(globalData[country][currentYear]);
      }

      function updateRadar(data) {
        radarSvg.selectAll("*").remove();  
        parameters.forEach(param => {
            scales[param] = d3.scaleLinear()
                .domain([
                    0,
                    d3.max(
                        Object.values(globalData).flatMap(countryData =>
                            Object.values(countryData).map(yearData => yearData[param] || 0)
                        )
                    )
                ])
                .range([0, radius]);
    
            console.log(`Scale for ${param}:`, scales[param].domain());
        });
    
        const radarGroup = radarSvg.append("g").attr("transform", `translate(${centerX}, ${centerY})`);
    
        for (let i = 1; i <= 5; i++) {
            radarGroup.append("circle")
                .attr("r", (radius / 5) * i)
                .style("fill", "none")
                .style("stroke", "#aaa");
        }
    
        parameters.forEach((param, i) => {
            const x = radius * Math.cos(angleSlice * i - Math.PI / 2);
            const y = radius * Math.sin(angleSlice * i - Math.PI / 2);
    
            radarGroup.append("line")
                .attr("x1", 0)
                .attr("y1", 0)
                .attr("x2", x)
                .attr("y2", y)
                .style("stroke", "gray");
    
            radarGroup.append("text")
                .attr("x", x * 1.1)
                .attr("y", y * 1.1)
                .style("text-anchor", "middle")
                .style("fill", "white")
                .text(param);
        });
    
        const formattedData = parameters.map(param => ({
            parameter: param,
            value: data[param] || 0 
        }));
    
        console.log("Formatted Data for Radar Chart:", formattedData);
    
        radarGroup.append("path")
            .datum(formattedData)
            .attr("d", radarLine)
            .style("fill", "lightblue")
            .style("stroke", "blue")
            .style("opacity", 0.7);
    }

      yearSlider.on("input", function () {
          currentYear = this.value;
          yearDisplay.text(currentYear);
          if (selectedCountry) {
              updateRadarCountry(selectedCountry);
          }
      });

    });

    //Bubble Plot
    const drawBubblePlot = async () => {

      //Load CSVs
      const [livingCosts, renewableEnergy, lifeExpectancy] = await Promise.all([
        d3.csv("Cost_of_Living_and_Income_Extended.csv"),
        d3.csv("global_renewable_energy_production.csv"),
        d3.csv("life_expectancy.csv")
      ]);

      //Pull needed data from datasets
      const totalEnergy = renewableEnergy.map(d => +d['TotalRenewableEnergy']);
      const totalExpectancy = lifeExpectancy.map(d => {
        const value = +d['Life Expectancy World Bank'];
        // Replace zero or invalid values with null
        return (value > 0) ? value : null;
      });
      const co2Values = lifeExpectancy.map(d => +d['CO2']);
      const totalIncome = lifeExpectancy.map(d => d['IncomeGroup']);

      //Merge the data arrays by index
      const mergedData = totalEnergy.map((energy, index) => {
        return {
          TotalRenewableEnergy: energy,
          LifeExpectancy: totalExpectancy[index],
          CO2: co2Values[index],
          IncomeGroup: totalIncome[index]
        };})
        //Need to filter out bad life expectancy values
        .filter(d => d.LifeExpectancy !== null 
        && !isNaN(d.LifeExpectancy) 
        && d.LifeExpectancy > 0 
        && !isNaN(d.TotalRenewableEnergy)
      );

      //Create chart dimensions
      const width = 1200;
      const height = 600;
      const margins = { top: 50, right: 150, bottom: 100, left: 100 };
      const chartWidth = width - margins.left - margins.right;
      const chartHeight = height - margins.top - margins.bottom;

      //Create SVG
      const svg = d3.select("#bubble-chart")
                    .append("svg")
                    .attr("width", width)
                    .attr("height", height);

      const chartArea = svg.append('g')
                          .attr('transform', `translate(${margins.left},${margins.top})`);

      //Designate scales for axes
      const xExtent = d3.extent(mergedData, d => d.TotalRenewableEnergy);
      const xScale = d3.scaleLinear()
                      .domain(xExtent)
                      .range([0, chartWidth]);

      const yExtent = d3.extent(mergedData, d => d.LifeExpectancy);
      const yScale = d3.scaleLinear()
                      .domain(yExtent)
                      .range([chartHeight, 0]);

      console.log(yExtent)

      //Designate scales for size and color variables
      const sizeExtent = d3.extent(mergedData, d => d.CO2);
      const sizeScale = d3.scaleLinear()
                          .domain(sizeExtent)
                          .range([2, 15]);

      const colorScale = d3.scaleOrdinal()
                          .domain(mergedData.map(d => d.IncomeGroup))
                          .range(["#DA3D2E", "#FFC845", "#1233A6", "#006F49"]);

      //Append the axes
      const leftAxis = d3.axisLeft(yScale);
      svg.append("g")
        .attr("class", "y axis")
        .attr("transform", `translate(${margins.left}, ${margins.top})`)
        .call(leftAxis);

      const bottomAxis = d3.axisBottom(xScale);
      svg.append("g")
        .attr("class", "x axis")
        .attr("transform", `translate(${margins.left}, ${height - margins.bottom})`)
        .call(bottomAxis);

      //Append the gridlines
      const leftGridlines = d3.axisLeft(yScale).tickFormat('').tickSize(-chartWidth);
      chartArea.append("g")
        .attr("class", "y gridlines")
        .call(leftGridlines);

      const bottomGridlines = d3.axisBottom(xScale).tickFormat('').tickSize(-chartHeight).ticks(6);
      chartArea.append("g")
        .attr("class", "x gridlines")
        .attr("transform", `translate(0, ${chartHeight})`)
        .call(bottomGridlines);

      //Add the y-axis label
      svg.append("text")
        .attr("class", "y label")
        .attr("text-anchor", "middle")
        .attr("font-weight", "bold")
        .attr("x", margins.left / 2)
        .attr("y", height / 2)
        .attr("transform", `rotate(-90, ${margins.left / 2}, ${height / 2})`)
        .text("Life Expectancy (Years)");

      //Add the x-axis label
      svg.append("text")
        .attr("class", "x label")
        .attr("text-anchor", "middle")
        .attr("font-weight", "bold")
        .attr("x", width / 2)
        .attr("y", height - 30)
        .text("Total Renewable Energy (GWh)");

      //Append the circles
      let circles = chartArea.selectAll("circle").data(mergedData)
                            .enter()
                            .append("circle")
                            .attr("cx", d => xScale(d.TotalRenewableEnergy))
                            .attr("cy", d => yScale(d.LifeExpectancy))
                            .attr("r", d => sizeScale(d.CO2) * 2)
                            .attr("fill", d => colorScale(d.IncomeGroup))
                            .attr("opacity", 0.7);

      //Create legend
      const legendWidth = (width - margins.right - margins.left) * 0.14;
      const legendHeight = 250;
      const legendX = width - margins.right + 10;
      const legendY = margins.top;

      //Legend background box
      const legendBox = svg.append("rect")
                          .attr("x", legendX)
                          .attr("y", legendY)
                          .attr("width", legendWidth)
                          .attr("height", legendHeight)
                          .attr("class", "legend-box")
                          .style("fill", "white")
                          .style("stroke", "black");

      //Legend title for Income Groups
      svg.append("text")
          .attr("x", legendX + legendWidth / 2)
          .attr("y", legendY + 20)
          .attr("text-anchor", "middle")
          .attr("font-weight", "bold")
          .text("Income Groups");

      //Append income group color indicators
      svg.append("circle")
        .attr("cx", legendX + 20) 
        .attr("cy", legendY + 20 + 1 * 25)
        .attr("r", 10)
        .attr("fill", "#006F49");

      svg.append("text")
        .attr("x", legendX + 40) 
        .attr("y", legendY + 20 + 1 * 25) 
        .attr("font-size", "12px")
        .attr("alignment-baseline", "middle")
        .text("High Income");
        
      svg.append("circle")
        .attr("cx", legendX + 20) 
        .attr("cy", legendY + 20 + 4 * 25)
        .attr("r", 10)
        .attr("fill", "#DA3D2E");

      svg.append("text")
        .attr("x", legendX + 40) 
        .attr("y", legendY + 20 + 4 * 25) 
        .attr("font-size", "12px")
        .attr("alignment-baseline", "middle")
        .text("Low Income");

      svg.append("circle")
        .attr("cx", legendX + 20) 
        .attr("cy", legendY + 20 + 3 * 25)
        .attr("r", 10)
        .attr("fill", "#ffc845");

      svg.append("text")
        .attr("x", legendX + 40) 
        .attr("y", legendY + 20 + 3 * 25) 
        .attr("font-size", "12px")
        .attr("alignment-baseline", "middle")
        .text("Low-mid Income");

      svg.append("circle")
        .attr("cx", legendX + 20) 
        .attr("cy", legendY + 20 + 2 * 25)
        .attr("r", 10)
        .attr("fill", "#1233A6");

      svg.append("text")
        .attr("x", legendX + 40) 
        .attr("y", legendY + 20 + 2 * 25) 
        .attr("font-size", "12px")
        .attr("alignment-baseline", "middle")
        .text("Upper-mid Income");

      //Append CO2 circle radius indicators
      svg.append("text")
          .attr("x", legendX + legendWidth / 2)
          .attr("y", legendY + 20 + 5.5 * 25)
          .attr("text-anchor", "middle")
          .attr("font-weight", "bold")
          .text("CO2 Value (kT)");

      svg.append("circle")
        .attr("cx", legendX + 13) 
        .attr("cy", legendY + 5 + 8 * 24)
        .attr("r", 6)
        .style("stroke", "black")
        .style("stroke-width", 1.5)
        .attr("fill", "none");

      svg.append("circle")
        .attr("cx", legendX + 46) 
        .attr("cy", legendY + 5 + 8 * 24)
        .attr("r", 16)
        .style("stroke", "black")
        .style("stroke-width", 1.5)
        .attr("fill", "none");

      svg.append("circle")
        .attr("cx", legendX + 99) 
        .attr("cy", legendY + 5 + 8 * 24)
        .attr("r", 26)
        .style("stroke", "black")
        .style("stroke-width", 1.5)
        .attr("fill", "none");

      svg.append("text")
        .attr("x", legendX + 12) 
        .attr("y", legendY + 48 + 8 * 24)
        .attr("font-size", "12px")
        .attr("alignment-baseline", "middle")
        .text("40.369 kT - 81.417 kT");
    }

    //Line Chart
    const drawMultiLineChart = async () => {
        // Load data
        const [renewableEnergyData, lifeExpectancyData] = await Promise.all([
          d3.csv("global_renewable_energy_production.csv"),
          d3.csv("life_expectancy.csv"),
        ]);

        // Parse and preprocess data
        const parseYear = d3.timeParse("%Y");
        const renewableGrouped = d3.group(renewableEnergyData, d => d.Year);
        const renewableCleaned = Array.from(renewableGrouped, ([year, records]) => ({
          year: parseYear(year),
          energy: d3.sum(records, r => +r.TotalRenewableEnergy),
        }));

        const lifeGrouped = d3.group(lifeExpectancyData, d => d.Year);
        const lifeCleaned = Array.from(lifeGrouped, ([year, records]) => ({
          year: parseYear(year),
          lifeExpectancy: d3.mean(records, r => +r["Life Expectancy World Bank"]),
          co2: d3.mean(records, r => +r.CO2),
        }));

        const mergedData = renewableCleaned.map(d => {
          const match = lifeCleaned.find(ld => ld.year.getTime() === d.year.getTime());
          return {
            year: d.year,
            energy: d.energy,
            lifeExpectancy: match ? match.lifeExpectancy : null,
            co2: match ? match.co2 : null,
          };
        }).filter(d => d.lifeExpectancy !== null && d.co2 !== null);


        const width = 1600;
        const height = 700;
        const margins = { top: 60, right: 400, bottom: 60, left: 160 };
        const chartWidth = width - margins.left - margins.right;
        const chartHeight = height - margins.top - margins.bottom;

        // Scales
        const xScale = d3.scaleTime()
          .domain(d3.extent(mergedData, d => d.year))
          .range([0, chartWidth]);

        const yScaleEnergy = d3.scaleLinear()
          .domain([0, d3.max(mergedData, d => d.energy)])
          .range([chartHeight, 0]);

        const yScaleLife = d3.scaleLinear()
          .domain([d3.min(mergedData, d => d.lifeExpectancy), d3.max(mergedData, d => d.lifeExpectancy)])
          .range([chartHeight, 0]);

        const yScaleCO2 = d3.scaleLinear()
          .domain([0, d3.max(mergedData, d => d.co2)])
          .range([chartHeight, 0]);

        // SVG setup
        const svg = d3.select("#chart")
          .append("svg")
          .attr("width", width)
          .attr("height", height);

        const chartArea = svg.append("g")
          .attr("transform", `translate(${margins.left},${margins.top})`);

        // Gridlines
        chartArea.append("g")
          .attr("class", "gridlines-life")

        chartArea.append("g")
          .attr("class", "gridlines-co2")

        // Axes
        chartArea.append("g")
          .attr("class", "y-axis-life")
          .call(d3.axisLeft(yScaleLife).ticks(7).tickPadding(5))
          .selectAll("text")
          .style("font-size", "15px");


        chartArea.append("g")
          .attr("class", "y-axis-co2")
          .attr("transform", `translate(-40,0)`)
          .call(d3.axisLeft(yScaleCO2).ticks(6).tickPadding(5))
          .selectAll("text")
          .style("font-size", "15px");


        chartArea.append("g")
          .attr("class", "y-axis-energy")
          .attr("transform", `translate(${chartWidth},0)`)
          .call(d3.axisRight(yScaleEnergy).ticks(5).tickPadding(5))
          .style("font-size", "15px");


        chartArea.append("g")
          .attr("transform", `translate(0,${chartHeight})`)
          .call(d3.axisBottom(xScale))
          .selectAll("text")
          .style("font-size", "15px")
          .style("fill", "black");

        // Line generators
        const lineEnergy = d3.line()
          .x(d => xScale(d.year))
          .y(d => yScaleEnergy(d.energy));

        const lineLife = d3.line()
          .x(d => xScale(d.year))
          .y(d => yScaleLife(d.lifeExpectancy));

        const lineCO2 = d3.line()
          .x(d => xScale(d.year))
          .y(d => yScaleCO2(d.co2));

        // Function to draw circles
        const drawCircles = (data, xScale, yScale, color, key) => {
          chartArea.selectAll(`circle.${key}`)
            .data(data)
            .enter()
            .append("circle")
            .attr("class", key)
            .attr("cx", d => xScale(d.year))
            .attr("cy", d => yScale(d[key]))
            .attr("r", 6)
            .attr("fill", color)
            .attr("opacity", 0.7); 

        };

        // Draw lines
        chartArea.append("path")
          .datum(mergedData)
          .attr("class", "line")
          .attr("d", lineEnergy)
          .attr("stroke", "#53C44F");

        chartArea.append("path")
          .datum(mergedData)
          .attr("class", "line")
          .attr("d", lineLife)
          .attr("stroke", "#5F9DD4");

        chartArea.append("path")
          .datum(mergedData)
          .attr("class", "line")
          .attr("d", lineCO2)
          .attr("stroke", "ED8D55");

        // Draw circles for each line
        drawCircles(mergedData, xScale, yScaleEnergy, "#53C44F", "energy");
        drawCircles(mergedData, xScale, yScaleLife, "#5F9DD4", "lifeExpectancy");
        drawCircles(mergedData, xScale, yScaleCO2, "#EC5042", "co2");

        const tooltip = d3.select("#tooltip");

        const drawLine = (data, lineGenerator, color, label) => {
          const lineGroup = chartArea.append("g");
          lineGroup.append("path")
            .datum(data)
            .attr("class", "line")
            .attr("d", lineGenerator)
            .attr("stroke", color)
            .style("cursor", "pointer")
            .on("mousemove", (event) => {
              const [x, y] = d3.pointer(event);
              const year = xScale.invert(x);
              const value = yScaleLife.invert(y);
              tooltip.style("display", "block")
                .style("left", `${event.pageX + 15}px`)
                .style("top", `${event.pageY - 15}px`)
                .html(`<b>${label}</b><br>Year: ${Math.round(year.getFullYear())}<br>Value: ${value.toFixed(2)}`);
            })
            .on("mouseout", () => tooltip.style("display", "none"));
        };

        drawLine(mergedData, lineEnergy, "#53C44F", "Renewable Energy");
        drawLine(mergedData, lineLife, "#5F9DD4", "Life Expectancy");
        drawLine(mergedData, lineCO2, "#EC5042", "CO2 Emissions");

        // Axis Labels
      
        svg.append("text")
          .attr("x", -chartHeight / 1.7) 
          .attr("y", margins.left / 5) 
          .attr("class", "axis-label")
          .attr("transform", "rotate(-90)") 
          .style("text-anchor", "middle") 
          .html(`
      <tspan fill="#5F9DD4">Life Expectancy (Yrs)  &nbsp; &nbsp; </tspan>
      <tspan fill="#EC5042">CO</tspan>
      <tspan fill="#EC5042" font-size="150%">₂</tspan>
      <tspan fill="#EC5042" dy="-0.2em"> Emissions (kT)</tspan>
      `);

        // Right Axis Label - Renewable Energy
        svg.append("text")
          .attr("x", 350) 
          .attr("y", -1290)
          .attr("class", "axis-label")
          .attr("transform", "rotate(90)")
          .style("fill", "#53C44F")
          .style("text-anchor", "middle") 
          .text("Renewable Energy (GWh)");


        svg.append("text")
          .attr("x", chartWidth / 1.55)
          .attr("y", height - 10)
          .attr("class", "axis-label")
          .text("Year")
          .style("text-anchor", "middle");

        // Legend
        const legend = svg.append("g")
          .attr("transform", `translate(${chartWidth + 250}, ${margins.top})`)
          .attr("class", "legend");

        legend.append("circle")
          .attr("cx", 0).attr("cy", 10).attr("r", 5).attr("fill", "#53C44F");
        legend.append("text")
          .attr("x", 15).attr("y", 14)
          .text("Total Annual Renewable Energy (GWh)");

        legend.append("circle")
          .attr("cx", 0).attr("cy", 30).attr("r", 5).attr("fill", "#5F9DD4");
        legend.append("text")
          .attr("x", 15).attr("y", 34)
          .text("Life Expectancy (Years)");

        legend.append("circle")
          .attr("cx", 0).attr("cy", 50).attr("r", 5).attr("fill", "#EC5042");
        legend.append("text")
          .attr("x", 15).attr("y", 54)
          .text("CO2 Emissions (kT)");
      };

      //Bar chart
      const RenewableEnergyChart = (function () {
          const svg = d3.select("svg#barchart");
          const width = svg.attr("width");
          const height = svg.attr("height");
          const margin = { top: 10, right: 10, bottom: 50, left: 50 };
          const chartWidth = width - margin.left - margin.right;
          const chartHeight = height - margin.top - margin.bottom;

          const annotations = svg.append("g").attr("id", "annotations");
          const chartArea = svg.append("g").attr("id", "points")
              .attr("transform", `translate(${margin.left}, ${margin.top})`);

          const tooltip = d3.select("#tooltip");

          const color = d3.scaleOrdinal()
              .domain(["SolarEnergy", "WindEnergy", "HydroEnergy", "OtherRenewableEnergy"])
              .range(d3.schemeSpectral[4]);

          let yearData;

          d3.csv('global_renewable_energy_production.csv').then(rawData => {
              rawData.forEach(d => {
                  d.Year = +d.Year;
                  d.SolarEnergy = +d.SolarEnergy;
                  d.WindEnergy = +d.WindEnergy;
                  d.HydroEnergy = +d.HydroEnergy;
                  d.OtherRenewableEnergy = +d.OtherRenewableEnergy;
              });

          yearData = d3.group(rawData, d => d.Year);

          const outputScale = d3.scaleLinear().range([chartHeight, 0]);
          const countryScale = d3.scaleBand().range([0, chartWidth]).padding(0.1);

          const leftAxis = d3.axisLeft(outputScale).ticks(10);
          const leftGridlines = d3.axisLeft(outputScale)
              .tickSize(-chartWidth - 10)
              .tickFormat("");
          annotations.append("g")
              .attr("class", "y gridlines")
              .attr("transform", `translate(${margin.left - 10},${margin.top})`)
              .call(leftGridlines);
          annotations.append("g")
              .attr("class", "y axis")
              .attr("transform", `translate(${margin.left},${margin.top})`)
              .call(leftAxis);
          annotations.append("text")
              .attr("class", "y-axis-label")
              .attr("transform", `translate(${margin.left - 40}, ${margin.top + chartHeight / 2}) rotate(-90)`)
              .style("text-anchor", "middle")
              .style("font-size", "8px")
              .style("fill", "#333")
              .text("(Hundreds of Thousands of MWh)");
          const bottomAxis = d3.axisBottom(countryScale);
          annotations.append("g")
              .attr("class", "x axis")
              .attr("transform", `translate(${margin.left},${chartHeight + margin.top + 10})`)
              .call(bottomAxis);

          function updateBarsAnimated(year) {
              const data = yearData.get(+year);
              const energyTypes = ["SolarEnergy", "WindEnergy", "HydroEnergy", "OtherRenewableEnergy"];
              const stackedData = d3.stack().keys(energyTypes)(data);

              countryScale.domain(data.map(d => d.Country));
              outputScale.domain([0, d3.max(data, d => d.SolarEnergy + d.WindEnergy + d.HydroEnergy + d.OtherRenewableEnergy)]);

              annotations.select(".y.axis")
                  .transition()
                  .call(leftAxis);

              annotations.select(".x.axis")
                  .transition()
                  .call(bottomAxis);

              chartArea.selectAll('g.layer')
                  .data(stackedData)
                  .join(
                      enter => enter.append('g')
                          .attr('class', 'layer')
                          .attr('fill', d => color(d.key))
                          .selectAll('rect')
                          .data(d => d)
                          .enter()
                          .append('rect')
                          .attr("x", d => countryScale(d.data.Country))
                          .attr("y", d => outputScale(d[1]))
                          .attr("height", d => outputScale(d[0]) - outputScale(d[1]))
                          .attr("width", countryScale.bandwidth())
                          .on("mouseover", (event, d) => {
                              const energyType = d3.select(event.target.parentNode).datum().key;
                              tooltip.style("display", "block")
                                  .html(`
                                      <strong>${d.data.Country}</strong><br>
                                      ${energyType}: ${(d[1] - d[0]).toLocaleString()} MWh
                                  `);
                          })
                          .on("mousemove", event => {
                              tooltip.style("top", (event.pageY + 10) + "px")
                                  .style("left", (event.pageX + 10) + "px");
                          })
                          .on("mouseout", () => {
                              tooltip.style("display", "none");
                          }),
                      update => update.selectAll('rect')
                          .data(d => d)
                          .join(
                              enter => enter.append('rect')
                                  .attr("x", d => countryScale(d.data.Country))
                                  .attr("y", d => outputScale(d[1]))
                                  .attr("height", d => outputScale(d[0]) - outputScale(d[1]))
                                  .attr("width", countryScale.bandwidth())
                                  .on("mouseover", (event, d) => {
                                      const energyType = d3.select(event.target.parentNode).datum().key;
                                      tooltip.style("display", "block")
                                          .html(`
                                              <strong>${d.data.Country}</strong><br>
                                              ${energyType}: ${(d[1] - d[0]).toLocaleString()} MWh
                                          `);
                                  })
                                  .on("mousemove", event => {
                                      tooltip.style("top", (event.pageY + 10) + "px")
                                          .style("left", (event.pageX + 10) + "px");
                                  })
                                  .on("mouseout", () => {
                                      tooltip.style("display", "none");
                                  }),
                              update => update.transition()
                                  .attr("x", d => countryScale(d.data.Country))
                                  .attr("y", d => outputScale(d[1]))
                                  .attr("height", d => outputScale(d[0]) - outputScale(d[1]))
                                  .attr("width", countryScale.bandwidth()),
                              exit => exit.transition().remove()
                          ),
                      exit => exit.transition().remove()
                  );
          }

          const years = Array.from(yearData.keys()).sort((a, b) => a - b);
          const buttonBar = d3.select("#button-bar");
          years.forEach(year => {
              buttonBar.append("button")
                  .text(year)
                  .on("click", () => updateBarsAnimated(year));
          });

          const legend = svg.append("g")
              .attr("id", "legend")
              .attr("transform", `translate(${chartWidth - 200}, ${margin.top})`);

          const energyTypes = ["Solar Energy", "Wind Energy", "Hydro Energy", "Other Renewable Energy"];
          legend.selectAll("g")
              .data(energyTypes)
              .join("g")
              .attr("class", "legend-item")
              .attr("transform", (d, i) => `translate(0, ${i * 20})`)
              .each(function (d) {
                  const g = d3.select(this);
                  g.append("rect")
                      .attr("x", 0)
                      .attr("y", 0)
                      .attr("width", 10)
                      .attr("height", 10)
                      .attr("fill", color(d));
                  g.append("text")
                      .attr("x", 25)
                      .attr("y", 14)
                      .text(d)
                      .style("font-size", "14px")
                      .style("fill", "#333");
              });

          // Initial year
          updateBarsAnimated(years[0]);
          });
      });

      drawRadarChart();
      drawMultiLineChart();
      drawBubblePlot();
      RenewableEnergyChart();
  </script>
</body>
</html>